- [IDEA快捷键整理](#idea快捷键整理)
  - [MarkDown](#markdown)
  - [ASCII码表](#ascii码表)
    - [ASCII码表（控制字符）](#ascii码表控制字符)
    - [ASCII码表（打印字符）](#ascii码表打印字符)
    - [ASCII码表（扩展字符）](#ascii码表扩展字符)
  - [汉字 ---\> 字节](#汉字-----字节)
  - [循环](#循环)
  - [跳转](#跳转)
  - [注释](#注释)
  - [继承](#继承)
  - [扩大所选范围【快速全选 div 标签】](#扩大所选范围快速全选-div-标签)
  - [绝对路径复制](#绝对路径复制)
  - [查看实现的方法](#查看实现的方法)
  - [目录跳转](#目录跳转)
  - [跳转至 开头 / 结尾](#跳转至-开头--结尾)
  - [格式化](#格式化)
  - [展开 / f折叠方法](#展开--f折叠方法)
  - [查看方法在哪里被调用](#查看方法在哪里被调用)
  - [SequeenceDiagram 时序图](#sequeencediagram-时序图)
  - [枚举类型遍历](#枚举类型遍历)
  - [运算符号整理](#运算符号整理)
    - [移位运算符](#移位运算符)
      - [有符号](#有符号)
      - [无符号](#无符号)
  - [math.pow方法](#mathpow方法)
  - [boolean数组初始化为 true](#boolean数组初始化为-true)
  - [Arrays.copyOf（）方法](#arrayscopyof方法)
  - [StringBuilder 清空](#stringbuilder-清空)
  - [subString() 方法](#substring-方法)
  - [String --- \> Char ---\> ASCII 码](#string------char-----ascii-码)
  - [ASCII 码 ---\> String](#ascii-码-----string)
  - [String.matches() 方法](#stringmatches-方法)
  - [Map.getOrDefault(key，默认值)；](#mapgetordefaultkey默认值)
  - [线程](#线程)
    - [获取当前线程 id](#获取当前线程-id)
    - [线程 dump](#线程-dump)
      - [1. jstack](#1-jstack)
        - [1.1 描述](#11-描述)
        - [1.2 操作](#12-操作)
        - [1.3 分析](#13-分析)
        - [1.4 相关概念](#14-相关概念)
        - [1.5 排查思路](#15-排查思路)
      - [2. 获取当前线程 dump](#2-获取当前线程-dump)
  - [集合相关方法](#集合相关方法)
    - [hash（）方法](#hash方法)
    - [根据 hash值 ---\> 下标](#根据-hash值-----下标)
    - [putVal（）方法](#putval方法)
    - [resize（）方法](#resize方法)
    - [treeifyBin(tab, hash)方法](#treeifybintab-hash方法)
      - [当 tab.length \< 64时，调用resize() 扩容](#当-tablength--64时调用resize-扩容)
      - [当 tab.length \>= 64时，调用 treeify(tab) 进行树化](#当-tablength--64时调用-treeifytab-进行树化)
    - [HashMap 3个方法](#hashmap-3个方法)
      - [1. keySet() 方法【Set 类型】](#1-keyset-方法set-类型)
      - [2. values() 方法【Collection 类型】](#2-values-方法collection-类型)
      - [3. entrySet() 方法【Set 类型】](#3-entryset-方法set-类型)
        - [getKey() 方法](#getkey-方法)
        - [getValue() 方法](#getvalue-方法)
    - [分析 HashSet 和 TreeSet 如何实现去重的](#分析-hashset-和-treeset-如何实现去重的)
    - [remove() 方法](#remove-方法)
    - [Collections 工具类](#collections-工具类)
  - [开发工具类](#开发工具类)
    - [1.  流的读写方法](#1--流的读写方法)
    - [2. 处理各种情况的用户输入](#2-处理各种情况的用户输入)
    - [3. 统计Web应用Servlet访问次数（ServletContext）](#3-统计web应用servlet访问次数servletcontext)
    - [4. Cookie 处理](#4-cookie-处理)
    - [5. 将一个字符串数字，转成 int](#5-将一个字符串数字转成-int)
    - [6. 判断一个文件是否是 html](#6-判断一个文件是否是-html)
    - [7. 根据文件名来读取文件 ---\> String](#7-根据文件名来读取文件-----string)
  - [字符串相关操作](#字符串相关操作)
    - [1. 字符串拼接](#1-字符串拼接)
    - [2. 判断字符串结尾是否是特定字串](#2-判断字符串结尾是否是特定字串)
    - [3. 读取子串](#3-读取子串)
    - [4. String.format() 格式化输出](#4-stringformat-格式化输出)
    - [5. 标题不超过15个字](#5-标题不超过15个字)
    - [6. Object ---\> String](#6-object-----string)
  - [显示编译后的文件夹](#显示编译后的文件夹)
  - [Package 和 Directory](#package-和-directory)
  - [Return](#return)
  - [Debug技巧](#debug技巧)
  - [复制过来的文件 IDEA 找不到](#复制过来的文件-idea-找不到)
  - [切换大小写](#切换大小写)
  - [并行执行](#并行执行)
  - [异常捕获](#异常捕获)
  - [插件](#插件)
  - [背景图片设置](#背景图片设置)
  - [Windows 软件安装](#windows-软件安装)
  - [JUnit 单元测试框架](#junit-单元测试框架)
  - [UML图相关快捷键](#uml图相关快捷键)
  - [虚拟机](#虚拟机)
    - [1. 本地客户端与虚拟机交互](#1-本地客户端与虚拟机交互)
  - [Maven](#maven)
    - [一、IDEA创建项目](#一idea创建项目)
    - [Usage](#usage)
    - [二、配置阿里云镜像](#二配置阿里云镜像)
    - [三、使用 maven 引入 jar 包](#三使用-maven-引入-jar-包)
    - [四、实现效果](#四实现效果)
  - [Java\_EE](#java_ee)
    - [1. 给浏览器返回信息](#1-给浏览器返回信息)
    - [2. login.html 登录界面](#2-loginhtml-登录界面)
    - [3. console.log()](#3-consolelog)
    - [4. DOM绑定](#4-dom绑定)
      - [4.1 静态绑定](#41-静态绑定)
      - [4.2 动态绑定](#42-动态绑定)
        - [为什么使用 windows.onload()?](#为什么使用-windowsonload)
        - [windows.onload 是什么?](#windowsonload-是什么)
        - [例子](#例子)
          - [1. 对对象操作，但是对象未被加载，操作失败](#1-对对象操作但是对象未被加载操作失败)
          - [2. 使用 windows.onload() 方法处理](#2-使用-windowsonload-方法处理)
    - [5. 将 login.html 改造成 servlet](#5-将-loginhtml-改造成-servlet)
        - [UserUISerlvet：负责界面](#useruiserlvet负责界面)
        - [LoginServlet 验证回送 Cookie](#loginservlet-验证回送-cookie)
        - [UserUIServlet：浏览器再次访问登录页面 UI 的时候，要读取 cookie](#useruiservlet浏览器再次访问登录页面-ui-的时候要读取-cookie)
    - [6. Servlet](#6-servlet)
      - [动态绑定(方法有，属性没有)](#动态绑定方法有属性没有)
      - [6.1 ServletConfig](#61-servletconfig)
        - [init（ServletConfig config）方法](#initservletconfig-config方法)
      - [6.2 ServletContext](#62-servletcontext)
        - [ServletContext 可以做什么](#servletcontext-可以做什么)
    - [7. cookie处理](#7-cookie处理)
      - [查找](#查找)
      - [修改](#修改)
      - [中文处理](#中文处理)
        - [URL 编码](#url-编码)
        - [URL 解码](#url-解码)
    - [8. jsp简易计算器（JS + 正则表达式）](#8-jsp简易计算器js--正则表达式)
    - [9. EL表达式 （替代 jsp表达式\<%=表达式%\>）](#9-el表达式-替代-jsp表达式表达式)
    - [10. 通过 Reploy 来清掉 Session](#10-通过-reploy-来清掉-session)
    - [11. jstl（替代jsp的代码脚本\<%%\>） 实现表格展示](#11-jstl替代jsp的代码脚本-实现表格展示)
    - [12. 时间戳](#12-时间戳)
    - [13. JS 正则表达式 【前端校验】](#13-js-正则表达式-前端校验)
    - [14. Web项目中 properties 路径问题](#14-web项目中-properties-路径问题)
    - [15. JavaWeb Debug 技巧](#15-javaweb-debug-技巧)
    - [16. 建表注意事项](#16-建表注意事项)
    - [17. entity 字段和 数据库中不一致的情况](#17-entity-字段和-数据库中不一致的情况)
    - [18. base 标签添加](#18-base-标签添加)
    - [19. hidden 标签添加【action】](#19-hidden-标签添加action)
    - [20. 前端错误信息提示【EL 表达式】](#20-前端错误信息提示el-表达式)
    - [21. 前端校验【在 head 中添加】](#21-前端校验在-head-中添加)
    - [22. 工具类DataUtils(底层使用（BeanUtils） 来完成自动封装JavaBean【⭐】](#22-工具类datautils底层使用beanutils-来完成自动封装javabean)
    - [23. post 提交时候不能使用？的方式来传入参数 ---\> 使用隐藏域 hidden 解决](#23-post-提交时候不能使用的方式来传入参数-----使用隐藏域-hidden-解决)
    - [24. 获取 表的行数](#24-获取-表的行数)
    - [25. 分页](#25-分页)
      - [jstl 表达式 \<c:if\>](#jstl-表达式-cif)
      - [jstl 表达式 \<c:foreach\>](#jstl-表达式-cforeach)
        - [普通遍历](#普通遍历)
        - [遍历数组](#遍历数组)
        - [遍历 Map](#遍历-map)
        - [遍历 List](#遍历-list)
      - [jstl 表达式 \<c:set\>](#jstl-表达式-cset)
    - [26. EL 的 11个隐含对象，可以直接使用](#26-el-的-11个隐含对象可以直接使用)
      - [如果页数很多，最多显示5个](#如果页数很多最多显示5个)
    - [27. JavaWeb Debug思考](#27-javaweb-debug思考)
    - [28. jsp 请求转发](#28-jsp-请求转发)
    - [29. JavaWeb 项目启动执行的文件](#29-javaweb-项目启动执行的文件)
    - [30. queryScalar转换成 int](#30-queryscalar转换成-int)
    - [31. jsp 文件为什么可以调用 request.getContextPath()](#31-jsp-文件为什么可以调用-requestgetcontextpath)
    - [32. Fuck!!!](#32-fuck)
    - [33. BigDecimal 乘法](#33-bigdecimal-乘法)
    - [34. todo标识使用](#34-todo标识使用)
    - [35. 验证 API（Servlet中的 具体方法）可以先用 url](#35-验证-apiservlet中的-具体方法可以先用-url)
    - [36. jQuery 取出标签内的某个属性](#36-jquery-取出标签内的某个属性)
    - [37. jQuery 点击跳转 URL【location.href】](#37-jquery-点击跳转-urllocationhref)
    - [38. 前端无法跳转分析【find in path】](#38-前端无法跳转分析find-in-path)
    - [39. confirm是否确认删除](#39-confirm是否确认删除)
    - [40. hashMap 本身提供了一个方法 clear](#40-hashmap-本身提供了一个方法-clear)
    - [41. Navicat 误关了窗口恢复](#41-navicat-误关了窗口恢复)
    - [42. 生成订单涉及多张表](#42-生成订单涉及多张表)
    - [43. Arrays类将数组转成 list](#43-arrays类将数组转成-list)
    - [44. 获得 url 方式](#44-获得-url-方式)
    - [45. 异常处理机制【参与业务逻辑】](#45-异常处理机制参与业务逻辑)
    - [46. 统一错误页面【Filter是由 Tomcat 创建的，在 Filter中将异常抛出给 Tomcat】](#46-统一错误页面filter是由-tomcat-创建的在-filter中将异常抛出给-tomcat)
    - [47. 数据 ---\> Map ---\> Json](#47-数据-----map-----json)
    - [48. 整合前端](#48-整合前端)
    - [49. 使用 ajax 过滤器失效，无法请求转发和重定向](#49-使用-ajax-过滤器失效无法请求转发和重定向)
    - [50. 工具类判断是否是 ajax 请求【request.getHeader("X-Requested-With")】](#50-工具类判断是否是-ajax-请求requestgetheaderx-requested-with)
    - [51. 如果表单是 enctype="multipart/form-data" 格式【无法 req.getparameter()】](#51-如果表单是-enctypemultipartform-data-格式无法-reqgetparameter)
    - [52. 增加业务逻辑使得 普通会员无法访问后台](#52-增加业务逻辑使得-普通会员无法访问后台)
    - [53. input type="file" 标签](#53-input-typefile-标签)
    - [54. 图片冗余问题【删除上次图片】](#54-图片冗余问题删除上次图片)
    - [55. 分页导航完善](#55-分页导航完善)
      - [if 嵌套](#if-嵌套)
      - [choose ---\> when 嵌套](#choose-----when-嵌套)
    - [56. promoise\_utils  工具](#56-promoise_utils--工具)
    - [57. VUE 引入](#57-vue-引入)
    - [58. 全局组件](#58-全局组件)
    - [59. 局部组件](#59-局部组件)
    - [60. HelloWorld.vue 原始代码](#60-helloworldvue-原始代码)
    - [61. Vue 非简写版本](#61-vue-非简写版本)
    - [62. Vue 请求页面执行流程](#62-vue-请求页面执行流程)
    - [63. table 不居中的原因](#63-table-不居中的原因)
    - [64. debugger 设置](#64-debugger-设置)
    - [65. Java Volatile关键字【触发刷新】](#65-java-volatile关键字触发刷新)
    - [66. beans.xml name 爆红](#66-beansxml-name-爆红)
    - [67. Spring 懒加载【Spring 默认不是懒加载，而是迫切加载】](#67-spring-懒加载spring-默认不是懒加载而是迫切加载)
    - [68. classpath](#68-classpath)
    - [69.  得到 web.xml 文件路径](#69--得到-webxml-文件路径)
    - [70. 通过类加载器获取要扫描包的真正路径](#70-通过类加载器获取要扫描包的真正路径)
    - [71. 2种 获得 Class 对象的反射方法的区别](#71-2种-获得-class-对象的反射方法的区别)
    - [72. 判断 Class 对象是否包含某个注解](#72-判断-class-对象是否包含某个注解)
    - [73. StringUtils工具类实现首字母小写](#73-stringutils工具类实现首字母小写)
    - [74. beans.xml 中 注解配置和XML配置并不冲突](#74-beansxml-中-注解配置和xml配置并不冲突)
    - [75. Spring 单例模式的理解【scope=singleton / prototype】](#75-spring-单例模式的理解scopesingleton--prototype)
    - [75. 开启AOP 注解  功能 \<aop:aspectj-autoproxy/\> ===\> 这样得到的 bean 才是 运行类型是 Proxy 的代理对象【编译类型是接口类型】，否则拿到的就是普通对象，普通对象是切不进去的](#75-开启aop-注解--功能-aopaspectj-autoproxy--这样得到的-bean-才是-运行类型是-proxy-的代理对象编译类型是接口类型否则拿到的就是普通对象普通对象是切不进去的)
    - [76. 切入点表达式复用【定义一个方法，添加注解@Pointcut(value="execution(...)"在后面使用时可以直接引用，提高复用性)】](#76-切入点表达式复用定义一个方法添加注解pointcutvalueexecution在后面使用时可以直接引用提高复用性)
    - [77. Maven 项目中 beans.xml 文件位置](#77-maven-项目中-beansxml-文件位置)
    - [78. JDK没有JAVAX.ANNOTATION.JAR包解决方案，无法使用@RESOURCE解决方案](#78-jdk没有javaxannotationjar包解决方案无法使用resource解决方案)
    - [79. 类加载器](#79-类加载器)
    - [79. 扫描路径scanDir 与 反射Path](#79-扫描路径scandir-与-反射path)
    - [80. 判断 Class 对象是否实现了某个接口](#80-判断-class-对象是否实现了某个接口)
    - [81. 在 main 方法中调用系统类加载器，并扫描文件夹](#81-在-main-方法中调用系统类加载器并扫描文件夹)
    - [82. 获取切面类方法的注解](#82-获取切面类方法的注解)
    - [83. 数组对象初始化](#83-数组对象初始化)
    - [84. 配置基于注解的声明式事务管理功能](#84-配置基于注解的声明式事务管理功能)
    - [85. SpringMVC 配置相关](#85-springmvc-配置相关)

# IDEA快捷键整理

## MarkDown

新建行：Ctrl + ENTER

单元格内另起一行（相当于 \<br>）：Ctrl + Shift + ENTER

标题：Ctrl + -

## ASCII码表

### ASCII码表（控制字符）

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol | HTML 实体编码 | 中文解释 Description |
| ---------- | ---------- | ------------ | ---------- | ----------- | ------------- | -------------------- |
| 0          | 000        | 00           | 00000000   | NUL         | &#000;        | 空字符               |
| 1          | 001        | 01           | 00000001   | SOH         | &#001;        | 标题开始             |
| 2          | 002        | 02           | 00000010   | STX         | &#002;        | 正文开始             |
| 3          | 003        | 03           | 00000011   | ETX         | &#003;        | 正文结束             |
| 4          | 004        | 04           | 00000100   | EOT         | &#004;        | 传输结束             |
| 5          | 005        | 05           | 00000101   | ENQ         | &#005;        | 询问                 |
| 6          | 006        | 06           | 00000110   | ACK         | &#006;        | 收到通知             |
| 7          | 007        | 07           | 00000111   | BEL         | &#007;        | 铃                   |
| 8          | 010        | 08           | 00001000   | BS          | &#008;        | 退格                 |
| 9          | 011        | 09           | 00001001   | HT          | &#009;        | 水平制表符           |
| 10         | 012        | 0A           | 00001010   | LF          | &#010;        | 换行键               |
| 11         | 013        | 0B           | 00001011   | VT          | &#011;        | 垂直制表符           |
| 12         | 014        | 0C           | 00001100   | FF          | &#012;        | 换页键               |
| 13         | 015        | 0D           | 00001101   | CR          | &#013;        | 回车键               |
| 14         | 016        | 0E           | 00001110   | SO          | &#014;        | 移出                 |
| 15         | 017        | 0F           | 00001111   | SI          | &#015;        | 移入                 |
| 16         | 020        | 10           | 00010000   | DLE         | &#016;        | 数据链路转义         |
| 17         | 021        | 11           | 00010001   | DC1         | &#017;        | 设备控制 1           |
| 18         | 022        | 12           | 00010010   | DC2         | &#018;        | 设备控制 2           |
| 19         | 023        | 13           | 00010011   | DC3         | &#019;        | 设备控制 3           |
| 20         | 024        | 14           | 00010100   | DC4         | &#020;        | 设备控制 4           |
| 21         | 025        | 15           | 00010101   | NAK         | &#021;        | 拒绝接收             |
| 22         | 026        | 16           | 00010110   | SYN         | &#022;        | 同步空闲             |
| 23         | 027        | 17           | 00010111   | ETB         | &#023;        | 传输块结束           |
| 24         | 030        | 18           | 00011000   | CAN         | &#024;        | 取消                 |
| 25         | 031        | 19           | 00011001   | EM          | &#025;        | 介质中断             |
| 26         | 032        | 1A           | 00011010   | SUB         | &#026;        | 替换                 |
| 27         | 033        | 1B           | 00011011   | ESC         | &#027;        | 换码符               |
| 28         | 034        | 1C           | 00011100   | FS          | &#028;        | 文件分隔符           |
| 29         | 035        | 1D           | 00011101   | GS          | &#029;        | 组分隔符             |
| 30         | 036        | 1E           | 00011110   | RS          | &#030;        | 记录分离符           |
| 31         | 037        | 1F           | 00011111   | US          | &#031;        | 单元分隔符           |

### ASCII码表（打印字符）

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol | HTML 实体编码 | 中文解释 Description |
| ---------- | ---------- | ------------ | ---------- | ----------- | ------------- | -------------------- |
| 32         | 040        | 20           | 00100000   |             | &#032;        | 空格                 |
| 33         | 041        | 21           | 00100001   | !           | &#033;        | 感叹号               |
| 34         | 042        | 22           | 00100010   | "           | &#034;        | 双引号               |
| 35         | 043        | 23           | 00100011   | #           | &#035;        | 井号                 |
| 36         | 044        | 24           | 00100100   | $           | &#036;        | 美元符               |
| 37         | 045        | 25           | 00100101   | %           | &#037;        | 百分号               |
| 38         | 046        | 26           | 00100110   | &           | &#038;        | 与                   |
| 39         | 047        | 27           | 00100111   | '           | &#039;        | 单引号               |
| 40         | 050        | 28           | 00101000   | (           | &#040;        | 左括号               |
| 41         | 051        | 29           | 00101001   | )           | &#041;        | 右括号               |
| 42         | 052        | 2A           | 00101010   | *           | &#042;        | 星号                 |
| 43         | 053        | 2B           | 00101011   | +           | &#043;        | 加号                 |
| 44         | 054        | 2C           | 00101100   | ,           | &#044;        | 逗号                 |
| 45         | 055        | 2D           | 00101101   | -           | &#045;        | 连字号或减号         |
| 46         | 056        | 2E           | 00101110   | .           | &#046;        | 句点或小数点         |
| 47         | 057        | 2F           | 00101111   | /           | &#047;        | 斜杠                 |
| 48         | 060        | 30           | 00110000   | 0           | &#048;        | 0                    |
| 49         | 061        | 31           | 00110001   | 1           | &#049;        | 1                    |
| 50         | 062        | 32           | 00110010   | 2           | &#050;        | 2                    |
| 51         | 063        | 33           | 00110011   | 3           | &#051;        | 3                    |
| 52         | 064        | 34           | 00110100   | 4           | &#052;        | 4                    |
| 53         | 065        | 35           | 00110101   | 5           | &#053;        | 5                    |
| 54         | 066        | 36           | 00110110   | 6           | &#054;        | 6                    |
| 55         | 067        | 37           | 00110111   | 7           | &#055;        | 7                    |
| 56         | 070        | 38           | 00111000   | 8           | &#056;        | 8                    |
| 57         | 071        | 39           | 00111001   | 9           | &#057;        | 9                    |
| 58         | 072        | 3A           | 00111010   | :           | &#058;        | 冒号                 |
| 59         | 073        | 3B           | 00111011   | ;           | &#059;        | 分号                 |
| 60         | 074        | 3C           | 00111100   | <           | &#060;        | 小于                 |
| 61         | 075        | 3D           | 00111101   | =           | &#061;        | 等号                 |
| 62         | 076        | 3E           | 00111110   | >           | &#062;        | 大于                 |
| 63         | 077        | 3F           | 00111111   | ?           | &#063;        | 问号                 |
| 64         | 100        | 40           | 01000000   | @           | &#064;        | 电子邮件符号         |
| 65         | 101        | 41           | 01000001   | A           | &#065;        | 大写字母 A           |
| 66         | 102        | 42           | 01000010   | B           | &#066;        | 大写字母 B           |
| 67         | 103        | 43           | 01000011   | C           | &#067;        | 大写字母 C           |
| 68         | 104        | 44           | 01000100   | D           | &#068;        | 大写字母 D           |
| 69         | 105        | 45           | 01000101   | E           | &#069;        | 大写字母 E           |
| 70         | 106        | 46           | 01000110   | F           | &#070;        | 大写字母 F           |
| 71         | 107        | 47           | 01000111   | G           | &#071;        | 大写字母 G           |
| 72         | 110        | 48           | 01001000   | H           | &#072;        | 大写字母 H           |
| 73         | 111        | 49           | 01001001   | I           | &#073;        | 大写字母 I           |
| 74         | 112        | 4A           | 01001010   | J           | &#074;        | 大写字母 J           |
| 75         | 113        | 4B           | 01001011   | K           | &#075;        | 大写字母 K           |
| 76         | 114        | 4C           | 01001100   | L           | &#076;        | 大写字母 L           |
| 77         | 115        | 4D           | 01001101   | M           | &#077;        | 大写字母 M           |
| 78         | 116        | 4E           | 01001110   | N           | &#078;        | 大写字母 N           |
| 79         | 117        | 4F           | 01001111   | O           | &#079;        | 大写字母 O           |
| 80         | 120        | 50           | 01010000   | P           | &#080;        | 大写字母 P           |
| 81         | 121        | 51           | 01010001   | Q           | &#081;        | 大写字母 Q           |
| 82         | 122        | 52           | 01010010   | R           | &#082;        | 大写字母 R           |
| 83         | 123        | 53           | 01010011   | S           | &#083;        | 大写字母 S           |
| 84         | 124        | 54           | 01010100   | T           | &#084;        | 大写字母 T           |
| 85         | 125        | 55           | 01010101   | U           | &#085;        | 大写字母 U           |
| 86         | 126        | 56           | 01010110   | V           | &#086;        | 大写字母 V           |
| 87         | 127        | 57           | 01010111   | W           | &#087         | 大写字母 W           |
| 88         | 130        | 58           | 01011000   | X           | &#088;        | 大写字母 X           |
| 89         | 131        | 59           | 01011001   | Y           | &#089;        | 大写字母 Y           |
| 90         | 132        | 5A           | 01011010   | Z           | &#090;        | 大写字母 Z           |
| 91         | 133        | 5B           | 01011011   | [           | &#091;        | 左中括号             |
| 92         | 134        | 5C           | 01011100   | \           | &#092;        | 反斜杠               |
| 93         | 135        | 5D           | 01011101   | ]           | &#093;        | 右中括号             |
| 94         | 136        | 5E           | 01011110   | ^           | &#094;        | 音调符号             |
| 95         | 137        | 5F           | 01011111   | _           | &#095;        | 下划线               |
| 96         | 140        | 60           | 01100000   | `           | &#096;        | 重音符               |
| 97         | 141        | 61           | 01100001   | a           | &#097;        | 小写字母 a           |
| 98         | 142        | 62           | 01100010   | b           | &#098;        | 小写字母 b           |
| 99         | 143        | 63           | 01100011   | c           | &#099;        | 小写字母 c           |
| 100        | 144        | 64           | 01100100   | d           | &#100;        | 小写字母 d           |
| 101        | 145        | 65           | 01100101   | e           | &#101;        | 小写字母 e           |
| 102        | 146        | 66           | 01100110   | f           | &#102;        | 小写字母 f           |
| 103        | 147        | 67           | 01100111   | g           | &#103;        | 小写字母 g           |
| 104        | 150        | 68           | 01101000   | h           | &#104;        | 小写字母 h           |
| 105        | 151        | 69           | 01101001   | i           | &#105;        | 小写字母 i           |
| 106        | 152        | 6A           | 01101010   | j           | &#106;        | 小写字母 j           |
| 107        | 153        | 6B           | 01101011   | k           | &#107;        | 小写字母 k           |
| 108        | 154        | 6C           | 01101100   | l           | &#108;        | 小写字母 l           |
| 109        | 155        | 6D           | 01101101   | m           | &#109;        | 小写字母 m           |
| 110        | 156        | 6E           | 01101110   | n           | &#110;        | 小写字母 n           |
| 111        | 157        | 6F           | 01101111   | o           | &#111;        | 小写字母 o           |
| 112        | 160        | 70           | 01110000   | p           | &#112;        | 小写字母 p           |
| 113        | 161        | 71           | 01110001   | q           | &#113;        | 小写字母 q           |
| 114        | 162        | 72           | 01110010   | r           | &#114;        | 小写字母 r           |
| 115        | 163        | 73           | 01110011   | s           | &#115;        | 小写字母 s           |
| 116        | 164        | 74           | 01110100   | t           | &#116;        | 小写字母 t           |
| 117        | 165        | 75           | 01110101   | u           | &#117;        | 小写字母 u           |
| 118        | 166        | 76           | 01110110   | v           | &#118;        | 小写字母 v           |
| 119        | 167        | 77           | 01110111   | w           | &#119;        | 小写字母 w           |
| 120        | 170        | 78           | 01111000   | x           | &#120;        | 小写字母 x           |
| 121        | 171        | 79           | 01111001   | y           | &#121;        | 小写字母 y           |
| 122        | 172        | 7A           | 01111010   | z           | &#122;        | 小写字母 z           |
| 123        | 173        | 7B           | 01111011   | {           | &#123;        | 左大括号             |
| 124        | 174        | 7C           | 01111100   | \|          | &#124;        | 垂直线               |
| 125        | 175        | 7D           | 01111101   | }           | &#125;        | 右大括号             |
| 126        | 176        | 7E           | 01111110   | ~           | &#126;        | 波浪号               |
| 127        | 177        | 7F           | 01111111   |             | &#127;        | 删除                 |

### ASCII码表（扩展字符）

| 十进制 DEC | 八进制 OCT | 十六进制 HEX | 二进制 BIN | 符号 Symbol | HTML 实体编码 | 中文解释 Description               |
| ---------- | ---------- | ------------ | ---------- | ----------- | ------------- | ---------------------------------- |
| 128        | 200        | 80           | 10000000   | €           | &#128;        | 欧盟符号                           |
| 129        | 201        | 81           | 10000001   |             |               |                                    |
| 130        | 202        | 82           | 10000010   | ‚           | &#130;        | 单低 9 引号                        |
| 131        | 203        | 83           | 10000011   | ƒ           | &#131;        | 带钩的 拉丁小写字母f               |
| 132        | 204        | 84           | 10000100   | „           | &#132;        | 双低 9 引号                        |
| 133        | 205        | 85           | 10000101   | …           | &#133;        | 水平省略号                         |
| 134        | 206        | 86           | 10000110   | †           | &#134;        | 剑号                               |
| 135        | 207        | 87           | 10000111   | ‡           | &#135;        | 双剑号                             |
| 136        | 210        | 88           | 10001000   | ˆ           | &#136;        | 修正字符 抑扬音符号                |
| 137        | 211        | 89           | 10001001   | ‰           | &#137;        | 千分号                             |
| 138        | 212        | 8A           | 10001010   | Š           | &#138;        | 带弯音号的 拉丁大写字母 S          |
| 139        | 213        | 8B           | 10001011   | ‹           | &#139;        | 左单书名号                         |
| 140        | 214        | 8C           | 10001100   | Œ           | &#140;        | 拉丁大写组合 OE                    |
| 141        | 215        | 8D           | 10001101   |             |               |                                    |
| 142        | 216        | 8E           | 10001110   | Ž           | &#142;        | 带弯音号的 拉丁大写字母 z          |
| 143        | 217        | 8F           | 10001111   |             |               |                                    |
| 144        | 220        | 90           | 10010000   |             |               |                                    |
| 145        | 221        | 91           | 10010001   | ‘           | &#145;        | 左单引号                           |
| 146        | 222        | 92           | 10010010   | ’           | &#146;        | 右单引号                           |
| 147        | 223        | 93           | 10010011   | “           | &#147;        | 左双引号                           |
| 148        | 224        | 94           | 10010100   | ”           | &#148;        | 右双引号                           |
| 149        | 225        | 95           | 10010101   | •           | &#149;        |                                    |
| 150        | 226        | 96           | 10010110   | –           | &#150;        | 半长破折号                         |
| 151        | 227        | 97           | 10010111   | —           | &#151;        | 全长破折号                         |
| 152        | 230        | 98           | 10011000   | ˜           | &#152;        | 小波浪线                           |
| 153        | 231        | 99           | 10011001   | ™           | &#153;        |                                    |
| 154        | 232        | 9A           | 10011010   | š           | &#154;        | 带弯音号的 拉丁小写字母 s          |
| 155        | 233        | 9B           | 10011011   | ›           | &#155;        | 右单书名号                         |
| 156        | 234        | 9C           | 10011100   | œ           | &#156;        | 拉丁小写组合 oe                    |
| 157        | 235        | 9D           | 10011101   |             |               |                                    |
| 158        | 236        | 9E           | 10011110   | ž           | &#158;        | 带弯音号的 拉丁小写字母 z          |
| 159        | 237        | 9F           | 10011111   | Ÿ           | &#159;        | 带弯音号的 拉丁大写字母 Y          |
| 160        | 240        | A0           | 10100000   |             | &#160;        |                                    |
| 161        | 241        | A1           | 10100001   | ¡           | &#161;        | 反向感叹号                         |
| 162        | 242        | A2           | 10100010   | ¢           | &#162;        | 分币符号                           |
| 163        | 243        | A3           | 10100011   | £           | &#163;        | 英磅符号                           |
| 164        | 244        | A4           | 10100100   | ¤           | &#164;        |                                    |
| 165        | 245        | A5           | 10100101   | ¥           | &#165;        | 人民币符号                         |
| 166        | 246        | A6           | 10100110   | ¦           | &#166;        |                                    |
| 167        | 247        | A7           | 10100111   | §           | &#167;        | 章节符号                           |
| 168        | 250        | A8           | 10101000   | ¨           | &#168;        | 通用货币符号                       |
| 169        | 251        | A9           | 10101001   | ©           | &#169;        | 版权符号                           |
| 170        | 252        | AA           | 10101010   | ª           | &#170;        | 阴性顺序 指示符号                  |
| 171        | 253        | AB           | 10101011   | «           | &#171;        | 左角引号                           |
| 172        | 254        | AC           | 10101100   | ¬           | &#172;        |                                    |
| 173        | 255        | AD           | 10101101   | ­           | &#173;        |                                    |
| 174        | 256        | AE           | 10101110   | ®           | &#174;        |                                    |
| 175        | 257        | AF           | 10101111   | ¯           | &#175;        |                                    |
| 176        | 260        | B0           | 10110000   | °           | &#176;        | 温度符号                           |
| 177        | 261        | B1           | 10110001   | ±           | &#177;        | 加/减号                            |
| 178        | 262        | B2           | 10110010   | ²           | &#178;        | 上标 2                             |
| 179        | 263        | B3           | 10110011   | ³           | &#179;        | 上标 3                             |
| 180        | 264        | B4           | 10110100   | ´           | &#180;        |                                    |
| 181        | 265        | B5           | 10110101   | µ           | &#181;        | 微符号                             |
| 182        | 266        | B6           | 10110110   | ¶           | &#182;        | 段落符号， pilcrow                 |
| 183        | 267        | B7           | 10110111   | ·           | &#183;        | 中点                               |
| 184        | 270        | B8           | 10111000   | ¸           | &#184;        |                                    |
| 185        | 271        | B9           | 10111001   | ¹           | &#185;        | 上标 1                             |
| 186        | 272        | BA           | 10111010   | º           | &#186;        | 阳性顺序 指示符                    |
| 187        | 273        | BB           | 10111011   | »           | &#187;        | 右角引号                           |
| 188        | 274        | BC           | 10111100   | ¼           | &#188;        | 分数四分之一                       |
| 189        | 275        | BD           | 10111101   | ½           | &#189;        | 分数二分之一                       |
| 190        | 276        | BE           | 10111110   | ¾           | &#190;        |                                    |
| 191        | 277        | BF           | 10111111   | ¿           | &#191;        | 反向问号                           |
| 192        | 300        | C0           | 11000000   | À           | &#192;        | 带重音符 的大写字母 A              |
| 193        | 301        | C1           | 11000001   | Á           | &#193;        | 带尖锐重音 的大写字母 A            |
| 194        | 302        | C2           | 11000010   | Â           | &#194;        | 带音调符号 的大写字母 A            |
| 195        | 303        | C3           | 11000011   | Ã           | &#195;        | 带代字号 的大写字母 A              |
| 196        | 304        | C4           | 11000100   | Ä           | &#196;        | 带元音变音 (分音符号) 的大写字母 A |
| 197        | 305        | C5           | 11000101   | Å           | &#197;        | 带铃声 的大写字母 A                |
| 198        | 306        | C6           | 11000110   | Æ           | &#198;        | 大写字母 AE 双重元音               |
| 199        | 307        | C7           | 11000111   | Ç           | &#199;        | 带变音符号 的大写字母 C            |
| 200        | 310        | C8           | 11001000   | È           | &#200;        | 带重音符 的大写字母 E              |
| 201        | 311        | C9           | 11001001   | É           | &#201;        | 带尖锐重音 的大写字母 E            |
| 202        | 312        | CA           | 11001010   | Ê           | &#202;        | 带音调符号 的大写字母 E            |
| 203        | 313        | CB           | 11001011   | Ë           | &#203;        | 带元音变音 (分音符号) 的大写字母 E |
| 204        | 314        | CC           | 11001100   | Ì           | &#204;        | 带重音符 的大写字母 I              |
| 205        | 315        | CD           | 11001101   | Í           | &#205;        | 带尖锐重音 的大写字母 I            |
| 206        | 316        | CE           | 11001110   | Î           | &#206;        | 带音调符号 的大写字母 I            |
| 207        | 317        | CF           | 11001111   | Ï           | &#207;        | 带元音变音 (分音符号) 的大写字母 I |
| 208        | 320        | D0           | 11010000   | Ð           | &#208;        |                                    |
| 209        | 321        | D1           | 11010001   | Ñ           | &#209;        | 带代字号 的大写字母 N              |
| 210        | 322        | D2           | 11010010   | Ò           | &#210;        | 带重音符 的大写字母 O              |
| 211        | 323        | D3           | 11010011   | Ó           | &#211;        | 带尖锐重音 的大写字母 O            |
| 212        | 324        | D4           | 11010100   | Ô           | &#212;        | 带音调符号 的大写字母 O            |
| 213        | 325        | D5           | 11010101   | Õ           | &#213;        | 带代字号 的大写字母 O              |
| 214        | 326        | D6           | 11010110   | Ö           | &#214;        | 带元音变音 (分音符号) 的大写字母 O |
| 215        | 327        | D7           | 11010111   | ×           | &#215;        | 大写字母 OE 连字                   |
| 216        | 330        | D8           | 11011000   | Ø           | &#216;        | 带斜杠 的大写字母 O                |
| 217        | 331        | D9           | 11011001   | Ù           | &#217;        | 带重音符 的大写字母 U              |
| 218        | 332        | DA           | 11011010   | Ú           | &#218;        | 带尖锐重音 的大写字母 U            |
| 219        | 333        | DB           | 11011011   | Û           | &#219;        | 带音调符号 的大写字母 U            |
| 220        | 334        | DC           | 11011100   | Ü           | &#220;        | 带元音变音 (分音符号) 的大写字母 U |
| 221        | 335        | DD           | 11011101   | Ý           | &#221;        | 带元音变音 (分音符号) 的大写字母 Y |
| 222        | 336        | DE           | 11011110   | Þ           | &#222;        |                                    |
| 223        | 337        | DF           | 11011111   | ß           | &#223;        | 德语高调 小写字母 s                |
| 224        | 340        | E0           | 11100000   | à           | &#224;        | 带重音符 的小写字母 a              |
| 225        | 341        | E1           | 11100001   | á           | &#225;        | 带尖锐重音 的小写字母 a            |
| 226        | 342        | E2           | 11100010   | â           | &#226;        | 带音调符号 的小写字母 a            |
| 227        | 343        | E3           | 11100011   | ã           | &#227;        | 带代字号 的小写字母 a              |
| 228        | 344        | E4           | 11100100   | ä           | &#228;        | 带元音变音 (分音符号) 的小写字母 a |
| 229        | 345        | E5           | 11100101   | å           | &#229;        | 带铃声的 小写字母 a                |
| 230        | 346        | E6           | 11100110   | æ           | &#230;        | 小写字母 ae 双重元音               |
| 231        | 347        | E7           | 11100111   | ç           | &#231;        | 带变音符号 的小写字母 c            |
| 232        | 350        | E8           | 11101000   | è           | &#232;        | 带重音符 的小写字母 e              |
| 233        | 351        | E9           | 11101001   | é           | &#233;        | 带尖锐重音 的小写字母 e            |
| 234        | 352        | EA           | 11101010   | ê           | &#234;        | 带音调符号 的小写字母 e            |
| 235        | 353        | EB           | 11101011   | ë           | &#235;        | 带元音变音 (分音符号) 的小写字母 e |
| 236        | 354        | EC           | 11101100   | ì           | &#236;        | 带重音符 的小写字母 i              |
| 237        | 355        | ED           | 11101101   | í           | &#237;        | 带尖锐重音 的小写字母 i            |
| 238        | 356        | EE           | 11101110   | î           | &#238;        | 带音调符号 的小写字母 i            |
| 239        | 357        | EF           | 11101111   | ï           | &#239;        | 带元音变音 (分音符号) 的小写字母 i |
| 240        | 360        | F0           | 11110000   | ð           | &#240;        |                                    |
| 241        | 361        | F1           | 11110001   | ñ           | &#241;        | 带代字号 的小写字母 n              |
| 242        | 362        | F2           | 11110010   | ò           | &#242;        | 带重音符 的小写字母 o              |
| 243        | 363        | F3           | 11110011   | ó           | &#243;        | 带尖锐重音 的小写字母 o            |
| 244        | 364        | F4           | 11110100   | ô           | &#244;        | 带音调符号 的小写字母 o            |
| 245        | 365        | F5           | 11110101   | õ           | &#245;        | 带代字号 的小写字母 o              |
| 246        | 366        | F6           | 11110110   | ö           | &#246;        | 带元音变音 (分音符号) 的小写字母 o |
| 247        | 367        | F7           | 11110111   | ÷           | &#247;        | 小写字母 oe 连字                   |
| 248        | 370        | F8           | 11111000   | ø           | &#248;        | 带斜杠 的小写字母 o                |
| 249        | 371        | F9           | 11111001   | ù           | &#249;        | 带重音符 的小写字母 u              |
| 250        | 372        | FA           | 11111010   | ú           | &#250;        | 带尖锐重音 的小写字母 u            |
| 251        | 373        | FB           | 11111011   | û           | &#251;        | 带音调符号 的小写字母 u            |
| 252        | 374        | FC           | 11111100   | ü           | &#252;        | 带元音变音 (分音符号) 的小写字母 u |
| 253        | 375        | FD           | 11111101   | ý           | &#253;        | 带元音变音 (分音符号) 的小写字母 y |
| 254        | 376        | FE           | 11111110   | þ           | &#254;        |                                    |
| 255        | 377        | FF           | 11111111   | ÿ           | &#255;        |                                    |

## 汉字 ---> 字节

```java
//  utf-8 编码下
//  1 个汉字 ---> 3个字节
public class dfafe {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str = "周";
        byte[] bytes = str.getBytes("utf-8");
        for (byte aByte : bytes) {
            System.out.println(aByte);
        }
    }
}
```

![image-20230119195346235](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202301191953295.png)

![image-20230119195407706](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202301191954771.png)

## 循环

- 普通 for 循环：fori
- 增强 for 循环：iter + Enter
- 迭代器：itit



## 跳转

- Ctrl + ⬅ / ➡ ：文件间跳转
- Ctrl + alt + ⬅ / ➡：返回刚才操作的位置



## 注释

- 注释有空格的问题
  - Editor --> Code Style --> Java --> Code Generation，设置"Add spaces around block" 替换成"Add a space at line comment start"



## 继承

- 查看一个类的层级关系（继承有用）：Ctrl + H

- 查看接口的子类：Ctrl + Alt + B

- 查看接口的父类：Ctrl + Alt + P
- 重写 接口/父类方法：Ctrl + o(overide)

## 扩大所选范围【快速全选 div 标签】

Ctrl + W

## 绝对路径复制

copy ---> Absolute Path

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171803960.png)

## 查看实现的方法

1. 接口方法：ctrl + 鼠标左键
2. 具体 <font color="yellow">**实现方法** </font>：Ctrl + ALT + B
   - 如果有多个类实现了该方法，它会来让你选择

## 目录跳转

1. Alt + 1 ：打开 project 目录
2. Alt + 7：打开 Structure  结构

## 跳转至 开头 / 结尾

CTRL + Home

CTRL + End

## 格式化

CTRL + ALT + L

格式化输出：

```java
for (int i = index; i >= 0; i--) {  //  从栈顶开始遍历
    System.out.format("stack[%d] = %d", i, stack[i]);
    System.out.println();
}
```

## 展开 / f折叠方法

- 单个方法：Ctrl + / -
- 全部方法：Shift + Ctrl + / - 

## 查看方法在哪里被调用

Ctrl + ALT + H

## SequeenceDiagram 时序图

![image-20221222174729889](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221747991.png)

设置：

- 调用的深度
- 跳过 getset方法
- 私有函数
- 构造函数
- 只显示项目本身代码

![image-20221222175010046](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221750091.png)

根据自己的需求，来查看响应方法的调用即可

## 枚举类型遍历

```java
//  获取该 filter所有的配置参数名
Enumeration<String> initParameterNames = filterConfig.getInitParameterNames();
//  枚举类型遍历
while (initParameterNames.hasMoreElements()){
    System.out.println("名字= " + initParameterNames.nextElement());
}
```

## 运算符号整理

### 移位运算符

#### 有符号

|      |      |
| ---- | ---- |
| >>   |      |
| <<   |      |

#### 无符号

|      |      |
| ---- | ---- |
| >>>  |      |
| <<<  |      |

## math.pow方法

注意：math方法返回值类型是 double

手写一个返回 int 类型的 pow

```java
public static int pow10(int i){
    int res = 1;
    for (int j = 0; j < i; j++) {
        res *= 10;
    }
    return res;
}
```



## boolean数组初始化为 true

```java
boolean[] toFill = new boolean[100] {};
Arrays.fill(toFill, true);
```

## Arrays.copyOf（）方法

```java
import java.util.Arrays;

public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5}; 
        int[] arr2 = Arrays.copyOf(arr1, 5);
        int[] arr3 = Arrays.copyOf(arr1, 10);
        for(int i = 0; i < arr2.length; i++) 
            System.out.print(arr2[i] + " "); 
        System.out.println();
        for(int i = 0; i < arr3.length; i++) 
            System.out.print(arr3[i] + " ");
    }
} 
```

运行结果如下：

```java
1 2 3 4 5 
1 2 3 4 5 0 0 0 0 0
```

## StringBuilder 清空

```java
sb.delete(0, sb.length());
```

## subString() 方法

遍历每个每一个字符

```java
public class sfesf {
    public static void main(String[] args) {
        String a = "fewaf";
        for (int i = 0; i < a.length(); i++) {
            String substring = a.substring(i, i + 1);
            System.out.println(substring);
        }
    }
}
```

## String --- > Char ---> ASCII 码

```java
if ((int)(aChar)>=0 && (int)(aChar)<= 126&&set.add(aChar)){
    count++;
}
```

## ASCII 码 ---> String

```java
String s2 = (ss.equals("z"))? "a" : (char)(ss.charAt(0) + 1) + "";
```

## String.matches() 方法

匹配大小写字母

## Map.getOrDefault(key，默认值)；

- Map中会存储一一对应的key和value。
  - 如果 在Map中存在key，则返回key所对应的的value。
  - 如果 在Map中不存在key，则返回默认值

```java
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String s = scanner.nextLine();
            char[] chars = s.toCharArray();
            //统计每个字母的数量
            HashMap<Character, Integer> map = new HashMap<>();
            for (char aChar : chars) {
                map.put(aChar, (map.getOrDefault(aChar, 0) + 1));
            }
            //找到数量最少的字符数量
            Collection<Integer> values = map.values();
            Integer min = Collections.min(values);

            //用空字符串替换该字母
            for (Character character : map.keySet()) {
                if (map.get(character) == min){
                    s = s.replaceAll(String.valueOf(character), "");	//	逐个删除
                }
            }
            System.out.println(s);
        }
    }
}
```

## 线程

![image-20221222190340837](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221903926.png)

### 获取当前线程 id

```java
Thread.currentThread().getId();
```

### 线程 dump

- 线程 dump 的目的是转存线程快照。（快照中是当前 JVM 所有线程正在执行方法的堆栈信息）
- 通过线程 dump 来分析定位线程出现长时间停顿的原因，如：
  - 线程死锁
  - 线程死循环
  - 线程请求外部资源长时间等待等

#### 1. jstack

##### 1.1 描述

- 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源（死循环、死锁）。
- 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
- jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现 <font color="blue">hung </font>【挂起、假死，这里的外在表现就是不报错，好像也不干活。但是也没有任何报错】的状态，jstack是非常有用的。

文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html#BABGJDIF

##### 1.2 操作

转存至快照，并通过查看当前进程中占用资源异常的线程 pid，快速定位到问题线程的堆栈信息

- 查看线程堆栈信息

  ```bash
  jstack [Pid] jstack -l -F [Pid] //查看进程是否存在死锁
  ```

- 转存线程堆栈映像文件

  ```bash
  jstack [pid]> loop.txt //jstack会自动找出死锁，并把死锁信息放在文件末尾
  ```

- 查看进程中线程资源占用情况

  ```bash
  top -p [pid] -H
  ```

- pid转十六进制

  ```bash
  printf "%x" 5016 //pid转十六进制为了查看dump文件中，该线程的堆栈信息（dump文件中，线程id以16进制呈现）
  ```

##### 1.3 分析

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221853876.png)

##### 1.4 相关概念

<font color="yellow">nid</font>：线程的<font color="yellow"> 唯一标识符</font> ，是 16 进制的，通常用于定位某个线程

java.lang.Thread.State：线程的状态标识

- NEW 未启动的新线程
- RUNNABLE 可运行的线程
  - Ready
  - Running
- TimedWaiting：超时等待
- Waiting：等待状态
- Blocked：阻塞状态（一般都是在等待锁资源）
- Terminated

##### 1.5 排查思路

- 线程状态的问题优先级：BLOCKED > WAITTING
- BLOCKED 状态的线程通常在 dump 文件的末尾部分
- 当发现某线程池中出现大量线程为 WAITTING 状态，需要查看一下线程的堆栈信息，必要则进行源代码分析

#### 2. 获取当前线程 dump

在断点调试的时候，我们可以通过点击下图红色箭头指向的相机图标，获取当前线程的dump信息。

这个功能有什么用呢？我们可以通过线程名，分析当前是哪个线程执行的，在多线程环境下对代码运行分析起到辅助作用。



比如下图1， `run()`方法是通过main主线程执行的，只是方法调用，并没有启动多线程（这是我们熟知结论的实践证明）

![图片](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221921290.png)

当我们把run方法改成`start()`方法时，可以看到是线程thread0执行的。

![图片](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212221930368.png)

## 集合相关方法

### hash（）方法

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
//	重写了 hashCode（）方法 = 100
//	所以：h = 100
//	最终结果为：100 ^ (100 >>> 16) = 100 ^ 0 = 100
```

### 根据 hash值 ---> 下标

```java
//	初始位置：15 & 100 = 4
if ((p = tab[i = (n - 1) & hash]) == null)	
//	31 & 100 = 4
//	63 & 100 = 36
```

### putVal（）方法

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {	
    Node<K,V>[] tab; Node<K,V> p; int n, i;	//	定义辅助变量
    if ((tab = table) == null || (n = tab.length) == 0)	//	初始化
        n = (tab = resize()).length;	//	n = 16（初始化容量大小为： 16）
    if ((p = tab[i = (n - 1) & hash]) == null)	//	计算 key 对应的 hash值，去计算该 key 应该在 table 表的哪一个索引位置去存放，并把这个位置的对象 赋给 辅助变量 p
        //	再判断是否为 null
        //	1）如果 p 为 null，表示还没有存放过元素，就创建一个 Node（key="java", value = PRESENT）放在该位置
        //	为什么把 key 对应的 hash 也存进去了，因为将来会去比较，如果再有的话，它会去看，如果相等会往后怼
        tab[i] = newNode(hash, key, value, null);
    else {
        //	辅助变量
        Node<K,V> e; K k;
        if (p.hash == hash &&	//	不能添加
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)	//	树
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {	//	链表【新加入的 Node，与链表中的 Node依次比较】
            for (int binCount = 0; ; ++binCount) {	
                if ((e = p.next) == null) {	//	能加的情况，还要看是否要树化，e = null
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // TREEIFY-THRESHOLD = 8【binCount 从0开始计数，当binCount = 0 时候，表示将要插入到第 2个位置；依次类推，binCount = 1 时，表示要插入到第 3个位置；所以当 binCount = 7时，表要要插入到第 9个位置。此时进行树化
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&	//	如果在循环过程中，发现有相同，就不添加了 break【e != null】只是替换 value
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;	//e = p (链表的首位置)
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;	// 更新 e.value = 新传进来的 value
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;	//	添加成功的次数
    if (++size > threshold)	//	 1 > threshold = 12 false
        resize();
    afterNodeInsertion(evict);	//	evict 默认是 true，在结点后插入 【对于 HashMap来说是空方法，目的是为了让它的子类去是实现这个方法，再做一些动作的】
    return null;
}
```

### resize（）方法

调用 Node<K, V>[] resize() 方法，初始化或加倍表大小

- 如果为 null，则按照字段阈值中保存的初始容量目标进行分配
- 否则，因为我们使用二次幂展开，每个 bin 中的元素必须保持相同的索引，或者在新表中以二次幂的偏移量移动

```java
/**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
//	allocates：分配
//	in accord with ：符合
//	power of two：二次幂

final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;	//	旧容量
    int oldThr = threshold;	//	旧阈值（初始为：0）
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults（初始化）
        newCap = DEFAULT_INITIAL_CAPACITY;	//	16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) { //	新阈值：16 * 0.75 = 12 != 0【table大小有16，但是只要用了12个，就要开始扩容了】
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;		//	更新 阈值 threshold = 12
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];	//	创建初始默认容量大小数组（16）
    table = newTab;
    if (oldTab != null) {	//	初始化时，oldTab == null，后面的代码都不执行，直接走到最后的 return
        for (int j = 0; j < oldCap; ++j) {	//	遍历旧 table 数组
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {	
                oldTab[j] = null;	//	将不为 null 的置 null
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;	//	扩容后 索引位置也会同步更新
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order 【原位置是链表的情况】
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;	//	返回初始容量大小数组
}
```

###  treeifyBin(tab, hash)方法

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)	//	n = tab.length = 64 【MIN_TREEIFY_CAPACITY=64】
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);	//	替换树  
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

#### 当 tab.length < 64时，调用resize() 扩容

#### 当 tab.length >= 64时，调用 treeify(tab) 进行树化

```java
// For treeifyBin
TreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {
    return new TreeNode<>(p.hash, p.key, p.value, next);
}
```

```java
/**
         * Forms tree of the nodes linked from this node.
         * 从此节点链接的节点的表单树
         */
final void treeify(Node<K,V>[] tab) {
    TreeNode<K,V> root = null;
    for (TreeNode<K,V> x = this, next; x != null; x = next) {
        next = (TreeNode<K,V>)x.next;
        x.left = x.right = null;
        if (root == null) {
            x.parent = null;
            x.red = false;
            root = x;
        }
        else {
            K k = x.key;
            int h = x.hash;
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph;
                K pk = p.key;
                if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0)
                    dir = tieBreakOrder(k, pk);

                TreeNode<K,V> xp = p;
                if ((p = (dir <= 0) ? p.left : p.right) == null) {
                    x.parent = xp;
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    root = balanceInsertion(root, x);
                    break;
                }
            }
        }
    }
    moveRootToFront(tab, root);
}
```

### HashMap 3个方法

####  1. keySet() 方法【Set 类型】

```java
Set set1 = map.keySet();
```

#### 2. values() 方法【Collection 类型】

#### 3. entrySet() 方法【Set 类型】

##### getKey() 方法

##### getValue() 方法

由于是 Set 类型，即实现了 Itarable 接口，可以使用迭代器

- 应用迭代器遍历时候，每个 entry 向下转型

```java
Map.Entry entry = (Map.Entry)iterator.next();
System.out.println(entry.getKey() + "-" + entry.getValue());	//	动态绑定到 HashMap$Node 类的 getKey 和 getValue() 方法，对应着 Node 的 key 和 value
```

### 分析 HashSet 和 TreeSet 如何实现去重的

1. HashSet
   - haasCode() + equals()
   - 底层先通过存入对象，进行运算得到一个 hash值，得到对应索引
     - 如果发现table 表索引所在的位置，没有数据，就直接存放
     - 如果有数据，就进行 equals 比较【遍历比较】
       - 比较后不相同，就加入
       - 否则不加入
2. TreeSet
   - 如果你传入了一个 Comparator匿名对象，就使用实现的 compare方法去重
     - 方法返回0，就认为是相同的元素 / 数据，就不添加了
   - 如果你没有传入Comparator匿名对象，则以你添加的对象实现的 Comparable 接口的 compareTo 去重

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    else {	//	现在没有传入 Comparactor 对象，代码走的是这部分了
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;	//	接口类型 ---> 实现这个接口的对象【向上转型】
        do {
            parent = t;
            cmp = k.compareTo(t.key);	//	调用了字符串本身的 compareTo() 方法 【动态绑定】
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry<K,V> e = new Entry<>(key, value, parent);
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}

```

分析下面代码是否会有异常：

```java
//	因为：现在没有传入 Comparactor接口的匿名内部类（对象）
//	所以，在底层会调用 添加的对象实现的 Comparable 接口的 compareTo 去重
//	走到了上述代码
//	即：把 Person 转成 Comparable 类型
//	由于这个 Person() 类不知道有没有实现 Comparable 接口，所以可能报错！！！---> 类型转换失败 ClassCastException
TreeSet treeSet = new TreeSet();
treeSet.add(new Person());	//	报错
```

注意：第一次添加的时候，也会进行类型转换

```java
//	第一次添加的时候，就会报错，类型转换异常
@SuppressWarnings("unchecked")
final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
```

### remove() 方法

```java
//	根据 obj 的 hash 值，会先算出在 table 中的位置，所过table表中该位置为null，则删除失败
//	删除成功的话，会返回 对应的 value 值
set.remove(obj);
```



```java
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
```

```java
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;	//	删除成功时，会返回被删掉的 key 对应的 value
}
```

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {	//	要删除的位置不为 null
        Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&	//	要删除位置的 hash
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {	//	链表的情况
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);	//	do-while  循环
            }
        }
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;	//	要删除的位置为 null
}
```





### Collections 工具类

java.util.Collections

1. Collections 是一个操作 Set、List 和 Map 等集合的工具类
2. 提供了一些系列静态放法对集合元素进行<font color="yellow">排序</font>、<font color="yellow"> 查询</font> 和<font color="yellow"> 修改</font> 等操作

```java
//	对象在集合中出现的次数
public static int frequency(Collection<?> c, Object o) {
    int result = 0;
    if (o == null) {
        for (Object e : c)
            if (e == null)
                result++;
    } else {
        for (Object e : c)
            if (o.equals(e))
                result++;
    }
    return result;
}
```



- 排序操作：（均为 static 方法）

  | 方法名                                                      | 作用                                                     |
  | ----------------------------------------------------------- | -------------------------------------------------------- |
  | reverse(List)                                               | 反转 List中的元素                                        |
  | shuffle(List) 【扑克牌洗牌】                                | 对 List 集合元素进行随机排序                             |
  | sort(List)                                                  | 根据元素的自然顺序对指定 List 集合元素按升序排序         |
  | sort(List, Comparator)                                      | 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 |
  | swap(List, int, int)                                        | 将指定 list 集合中的 i 处元素和 j 处元素进行交换         |
  | Object max(Collection)                                      | 根据元素的自然顺序，返回给定集合中的最大元素             |
  | Object max(Collection, Comparator)                          | 根据 Comparator 指定的顺序，返回给定集合中的最大元素     |
  | Object min(Collection)                                      |                                                          |
  | Object min(Collection, Comparator)                          |                                                          |
  | int frequency(Collection, Object)                           | 返回指定集合中指定元素的出现次数                         |
  | void copy(List dest, List src)                              | 将 src 中的内容复制到 dest中                             |
  | boolean replaceAll(List list, Object oldVal, Object newVal) | 使用 新值替换 List 对象的所有旧值                        |

  ```java
  Collections.max(list, new Comparator() {
  
      @Override
      public int compare(Object o1, Object o2) {
          return ((String)o1).length() - ((String)o2).length();
      }
  });
  ```

  ```java
  //	为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size() 一样
  for(int i = 0; i < list.size(); i++){
      dest.add("");
  }
  ```

  

 

## 开发工具类

### 1.  流的读写方法

```java
/**
 * 此类用于演示关于流的读写方法
 */
public class StreamUtils {
    /**
	 * 功能：将输入流转换成byte[] ---> 即：可以把一个文件写入（输出）到 byte[]
	 */
    public static byte[] streamToByteArray(InputStream is) throws Exception{	//	可以接受一个输入流，当然InputStream是
        //	一个抽象类，所以只要是它的子类对象
        //	都可以传进来
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象
        byte[] b = new byte[1024];	//	字节数组
        int len;
        while((len=is.read(b))!=-1){	//	循环读取
            bos.write(b, 0, len);	//	读取到的数据（字节数组），写入到 bos 中去
        }
        byte[] array = bos.toByteArray();	//	然后将 bos 转成一个字节数组
        bos.close();
        return array;
    }
    /**
	 * 功能：将InputStream转换成String
     * 将输入流的数据直接给你转成一个字符串
	 */

    public static String streamToString(InputStream is) throws Exception{
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        StringBuilder builder= new StringBuilder();
        String line;
        while((line=reader.readLine())!=null){  //    当读取到 null 时，就表示结束
            builder.append(line+"\r\n");
        }
        return builder.toString();
    }
}
```

### 2. 处理各种情况的用户输入

```java
/**
	工具类的作用:
	处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入。
*/

import java.util.*;
/**

*/
public class Utility {
    //静态属性。。。
    private static Scanner scanner = new Scanner(System.in);


    /**
     * 功能：读取键盘输入的一个菜单选项，值：1——5的范围
     * @return 1——5
     */
    public static char readMenuSelection() {
        char c;
        for (; ; ) {
            String str = readKeyBoard(1, false);//包含一个字符的字符串
            c = str.charAt(0);//将字符串转换成字符char类型
            if (c != '1' && c != '2' && 
                c != '3' && c != '4' && c != '5') {
                System.out.print("选择错误，请重新输入：");
            } else break;
        }
        return c;
    }

    /**
	 * 功能：读取键盘输入的一个字符
	 * @return 一个字符
	 */
    public static char readChar() {
        String str = readKeyBoard(1, false);//就是一个字符
        return str.charAt(0);
    }
    /**
     * 功能：读取键盘输入的一个字符，如果直接按回车，则返回指定的默认值；否则返回输入的那个字符
     * @param defaultValue 指定的默认值
     * @return 默认值或输入的字符
     */

    public static char readChar(char defaultValue) {
        String str = readKeyBoard(1, true);//要么是空字符串，要么是一个字符
        return (str.length() == 0) ? defaultValue : str.charAt(0);
    }

    /**
     * 功能：读取键盘输入的整型，长度小于2位
     * @return 整数
     */
    public static int readInt() {
        int n;
        for (; ; ) {
            String str = readKeyBoard(2, false);//一个整数，长度<=2位
            try {
                n = Integer.parseInt(str);//将字符串转换成整数
                break;
            } catch (NumberFormatException e) {
                System.out.print("数字输入错误，请重新输入：");
            }
        }
        return n;
    }
    /**
     * 功能：读取键盘输入的 整数或默认值，如果直接回车，则返回默认值，否则返回输入的整数
     * @param defaultValue 指定的默认值
     * @return 整数或默认值
     */
    public static int readInt(int defaultValue) {
        int n;
        for (; ; ) {
            String str = readKeyBoard(10, true);
            if (str.equals("")) {
                return defaultValue;
            }

            //异常处理...
            try {
                n = Integer.parseInt(str);
                break;
            } catch (NumberFormatException e) {
                System.out.print("数字输入错误，请重新输入：");
            }
        }
        return n;
    }

    /**
     * 功能：读取键盘输入的指定长度的字符串
     * @param limit 限制的长度
     * @return 指定长度的字符串
     */

    public static String readString(int limit) {
        return readKeyBoard(limit, false);
    }

    /**
     * 功能：读取键盘输入的指定长度的字符串或默认值，如果直接回车，返回默认值，否则返回字符串
     * @param limit 限制的长度
     * @param defaultValue 指定的默认值
     * @return 指定长度的字符串
     */

    public static String readString(int limit, String defaultValue) {
        String str = readKeyBoard(limit, true);
        return str.equals("")? defaultValue : str;
    }


    /**
	 * 功能：读取键盘输入的确认选项，Y或N
	 * 将小的功能，封装到一个方法中.
	 * @return Y或N
	 */
    public static char readConfirmSelection() {
        System.out.println("请输入你的选择(Y/N)");
        char c;
        for (; ; ) {//无限循环
            //在这里，将接受到字符，转成了大写字母
            //y => Y n=>N
            String str = readKeyBoard(1, false).toUpperCase();
            c = str.charAt(0);
            if (c == 'Y' || c == 'N') {
                break;
            } else {
                System.out.print("选择错误，请重新输入：");
            }
        }
        return c;
    }

    /**
     * 功能： 读取一个字符串
     * @param limit 读取的长度
     * @param blankReturn 如果为true ,表示 可以读空字符串。 
     * 					  如果为false表示 不能读空字符串。
     * 			
	 *	如果输入为空，或者输入大于limit的长度，就会提示重新输入。
     * @return
     */
    private static String readKeyBoard(int limit, boolean blankReturn) {

        //定义了字符串
        String line = "";

        //scanner.hasNextLine() 判断有没有下一行
        while (scanner.hasNextLine()) {
            line = scanner.nextLine();//读取这一行

            //如果line.length=0, 即用户没有输入任何内容，直接回车
            if (line.length() == 0) {
                if (blankReturn) return line;//如果blankReturn=true,可以返回空串
                else continue; //如果blankReturn=false,不接受空串，必须输入内容
            }

            //如果用户输入的内容大于了 limit，就提示重写输入  
            //如果用户如的内容 >0 <= limit ,我就接受
            if (line.length() < 1 || line.length() > limit) {
                System.out.print("输入长度（不能大于" + limit + "）错误，请重新输入：");
                continue;
            }
            break;
        }

        return line;
    }
}
```

### 3. 统计Web应用Servlet访问次数（ServletContext）  

```java
public class WebUtils {
    //  这个方法就是对访问次数的累积，同时返回次数
    public static Integer visitCount(ServletContext servletContext) {
        //  从 servletContext 中获取 visit_count 属性 k - v
        Object visit_count = servletContext.getAttribute("visit_count");
        //  判断 visit_count 是否为 null
        if (visit_count == null) {  //  说明是第一次访问网站
            servletContext.setAttribute("visit_count", 1);
            visit_count = 1;
        }else { //  第二次或者以后
            //  取出 visit_count 属性值 + 1
            visit_count = Integer.parseInt(visit_count + "") + 1;
            //    再放回到 servletContent中
            servletContext.setAttribute("visit_count", visit_count);
        }
        return Integer.parseInt(visit_count + "");
    }
}
```

将来想要统计哪个Web应用 Servlet访问的次数，只需要访问这个方法即可

### 4. Cookie 处理

```java
//	查找
public class CookieUtils {

    //  编写一个方法，返回指定名字的 cookie 值
    public static Cookie readCookieByName(String name, Cookie[] cookies){
        //  判断传入的参数是否正确
        if (name == null || "".equals(name) || cookies == null || cookies.length == 0){
            return null;
        }
        for (Cookie cookie : cookies) {
            if (name.equals(cookie.getName())){ //  如果名字相同
                return cookie;
            }
        }
        //  如果遍历完了之后，还是没有，就返回 null
        return null;
    }
}
```

```java
//	修改
public class UpdateCookie {
    public static Cookie updateCookieByName(String name, Cookie[] cookies){
        if (name == null || "".equals(name) || cookies == null || cookies.length == 0){
            return null;
        }
        for (Cookie cookie : cookies) {
            if (name.equals(cookie.getName())) {
                cookie.setValue("hiLLQ");
                return cookie;
            }
        }
        return null;
    }
}

//	注意：如果希望我们的浏览器本地的 cookie 也修改，则需要使用
if (cookie != null){
	response.addCookie(cookie);
}
```

### 5. 将一个字符串数字，转成 int

```java
public static int parseInt(String str, int defaultVal){
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException e) {
        System.out.println(str + "格式不对，转换失败");
    }
    return  defaultVal;
}
```

### 6. 判断一个文件是否是 html

```java
public static boolean isHtml(String uri){
    return uri.endsWith(".html");
}
```

### 7. 根据文件名来读取文件 ---> String

```java
//  根据文件名来读取该文件 ---> String
public static String readHtml(String filename) {
    String path = WebUtils.class.getResource("/").getPath();
    StringBuilder stringBuilder = new StringBuilder();
    try {
        BufferedReader br = new BufferedReader(new FileReader(path + filename));
        String buf = "";
        while ((buf = br.readLine()) != null) {
            stringBuilder.append(buf);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return stringBuilder.toString();
}
```

## 字符串相关操作

### 1. 字符串拼接

先占位

```java
String mes = HspResponse.respHeader + "<h1>num1+num2=sum</h1>";
```

然后将其中一个删掉，并在左右两侧添加逗号

```java
String mes = HspResponse.respHeader + "<h1>"+num1+"+num2=sum</h1>";
```

```java
String mes = HspResponse.respHeader + "<h1>"+num1+"+"+num2+"=sum</h1>";
```

```java
String mes = HspResponse.respHeader + "<h1>" + num1 + " +" +num2 + " = " + sum + "</h1>";
```



### 2. 判断字符串结尾是否是特定字串

```java
return uri.endWith(".html");
```

### 3. 读取子串

```java
uri.substring(1);
```

### 4. String.format() 格式化输出

```java
//  思路：讲结果组装到一个字符串中，方便我们在下一个页面显示
String resInfo = String.format("%s %s %s = %s", num1, symbol, num2, res);
request.setAttribute("resInfo", resInfo);
```

### 5. 标题不超过15个字

```java
if (title.length() > 15){
    title = title.substring(0, 15) + "...";
}
```

### 6. Object ---> String

```java
Object visit_count = servletContext.getAttribute("visit_count");
visit_count = Integer.parseInt(visit_count+"") + 1;
servletContext.setAttribute("visit_count", integer);	//	类似 hashMap 修改（替换）
```



## 显示编译后的文件夹

target 目录查看与隐藏

show Excluded Files



## Package 和 Directory

![image-20221124205924621](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211242059073.png)

只有 Sources Root 目录才可以创建 package，其它只能创建目录 directory

## Return

1. 没有返回值的方法中：如果触发了 return，那么后面的语句就都不执行了

## Debug技巧

- 快捷键修改 Appearance & Behavior ---> Keymap，然后搜索 debug
- 改为 Alt + D
- F9（Resume Program）：断点跳转

## 复制过来的文件 IDEA 找不到

Build ---> Rebuild Project

## 切换大小写

Ctrl + Shift + U

## 并行执行

模拟多个用户登录

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291949568.png)

Edit Configurations

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291949731.png)

勾选 Allow parallerl run

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291950606.png)

## 异常捕获

- Ctrl + Alt + T：try-catch-finally 捕获异常



## 插件

1. LeetCode插件

   - 下载 LeetCode Editor插件

   - File ---> Settings ---> Tools ---> leetcode plugin

   - 参数说明：

     Custom code template: 开启使用自定义模板，否则使用默认生成格式 CodeFileName: 生成文件的名称，默认为题目标题 

     CodeTemplate: 生成题目代码的内容，默认为题目描述和题目代码 

     TemplateConstant： 模板常用变量

     ${question.title}：题目标题，例如:两数之和
     $
   
     {question.titleSlug}：题目标记，例如:two-sum
     ${question.frontendQuestionId}：题目编号，例如:1
   
     ${question.content}：题目描述内容
     $

     {question.code}：题目代码部分
     $!velocityTool.camelCaseName(str)：一个函数，用来将字符串转化为驼峰样式
   
   - 配置
   
     - CodeFileName这个里面填的就是以后自动生成类的类名
   
       ```shell
       $!velocityTool.camelCaseName(${question.titleSlug}) 
       ```
   
     - CodeTemplate：自动生成的代码格式
   
       ```java
       package leetcode.editor.cn;
       
       ${question.content}
       public class $!velocityTool.camelCaseName(${question.titleSlug}){
       	public static void main(String[] args) {
       		Solution solution = new $!velocityTool.camelCaseName(${question.titleSlug})().new Solution();
       		
       	}
       ${question.code}
       }
       ```
   
       ![image-20221108171714048](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211081717109.png)

​	新版的谷歌浏览器根本就抓不到 Cookie，微软Edge倒是可以抓到，但是没用

​	关于插件的问题，是由于 LeetCode域名更换了，是需要升级到 8.1版本，但是我的IDEA版本匹配不上，就先不折腾了。

​	最后解决方法：更改临时配置文件

- 修改临时变量

  - 打开 C:\Users\李隆齐\AppData\Roaming\JetBrains\IntelliJIdea2020.1\options 

  - 将里面的`leetcode-cn.com`字段替换成`leetcode.cn`

## 背景图片设置

使用 Alt + B 进行设置

![image-20221120111805687](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211201118799.png)

## Windows 软件安装

- X86：32位
- WIN64：64位

## JUnit 单元测试框架

- @Test：Alt + Enter
- 先写方法，再加上@Test



## UML图相关快捷键

- 查看源码：F4

- 在UML图上方可以查看 ：
  - 字段
  - 构造器
  - 方法
- 使用空格来搜索并添加类
- Show Dependencies：体现在局部变量，方法的参数，或者对静态方法的调用

## 虚拟机

### 1. 本地客户端与虚拟机交互

查看服务器端口连接

```ba
netstat -anutp
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211292037888.png)

虽然客户端和服务器都哟 User，但是路径不同（交互的时候会带着路径）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211292038789.png)

所以，客户端发送给服务器端时，服务器无法识别！！！

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211292040652.png)

而左边强制转换的 User，则是当前目录的，所以目录要改为和客户端一致才可以。

## Maven 

### 一、IDEA创建项目

1. 利用 maven 配置 web 项目

   Archetype（模板原型）

   - cocoon-22-archetype-webapp![image-20221110153017416](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101530458.png)

   - maven-archetype-quickstart![image-20221110153035109](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101530150.png)
   - maven-archetype-webapp![image-20221110153116451](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101531491.png)

   https://maven.apache.org/archetypes/maven-archetype-webapp/

   1. project
   2. |-- pom.xml
   3. `-- src
   4. ​    `-- main
   5. ​        `-- webapp
   6. ​            |-- WEB-INF
   7. ​            |   `-- web.xml
   8. ​            `-- index.jsp

   ### Usage

   To generate a new project from this archetype, type:

   mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4![image-20221110154811820](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101548872.png)

2. Artifact Coordinates【<font color="blue">GroupId</font> 和 <font color="blue">ArtifactId</font> 统称为<font color="red">坐标</font>：可以唯一标识一个项目】

   - GroupId：公司信息
     - 一般是 com.公司名称

   - ArtifactId：项目名称
     - 通常就是项目名

3. 指定 maven

   	- 这里使用 IDEA自带的 maven: D:/Program Files (x86)/JetBrains/IntelliJ IDEA 2020.1.2/plugins/maven/lib/maven3

4. User setting file

   - Maven配置文件（默认是国外的仓库）---> 在 settings.xml 中配置 maven 镜像

5. Local repository

   - 本地仓库：从 maven 仓库下载的包，放到哪里



### 二、配置阿里云镜像

![image-20221109204435132](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211092044343.png)

IDEA中自带的 settings.xml

```bash
D:/Program Files (x86)/JetBrains/IntelliJ IDEA 2020.1.2/plugins/maven/lib/maven3
```

![image-20221109204724753](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211092047814.png)

将这个 settings.xml 文件复制过来

```bash
C:\Users\李隆齐\.m2\settings.xml
```

修改配置

https://developer.aliyun.com/mvn/guide

```xml
 <mirrors>
		<mirror>
			<!-- 指定镜像ID（可以自己改名） -->
			<id>nexus-aliyun</id>
			<!-- 匹配中央仓库（阿里云的仓库名称，不可以自己起名，必须这么写）-->
			<mirrorOf>central</mirrorOf>
			<!-- 指定镜像名称（可以自己改名）-->
			<name>Nexus aliyun</name>
			<!-- 指定镜像路径（镜像地址）-->
			<url>https://maven.aliyun.com/nexus/content/repositories/central</url>
		</mirror>
    <!-- mirror
     | Specifies a repository mirror site to use instead of a given repository. The repository that
     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
     |
    <mirror>
      <id>mirrorId</id>
      <mirrorOf>repositoryId</mirrorOf>
      <name>Human Readable Name for this Mirror.</name>
      <url>http://my.repository.com/repo/path</url>
    </mirror>
     -->
  </mirrors>
```

### 三、使用 maven 引入 jar 包

在pom.xml中配置依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.wangyi</groupId>
  <artifactId>aclq_tomcat</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>aclq_tomcat Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--
        老韩解读
        1.  引入 servlet-api.jar，为了开发 servlet
        2.  dependency 标签是标识要引入一个包
        3.  groupId：包的开发公司相关信息
        4.  artifactId：项目名  javax.servlet-api
            补充：groupId + artifactId 是以目录形式
        5.  version 版本
        6.  scope 表示引入的包的作用范围
        7.  provided：表示 tomcat 本身有jar 包，这里你引入的 jar 包，在编译，测试是有效，但是在打包发布的时候，不要带上这个 jar 包
        8.  下载的包在你指定的目录： C:\Users\李隆齐\.m2\repository
        9.  可以去修改我们要下载包的位置
        10. 我们可以去指定 maven 仓库，即：配置maven镜像
      -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>aclq_tomcat</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

```

下载的包在你指定的目录 C:\Users\李隆齐\.m2\repository

![image-20221110003531470](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211100035531.png)

Reload All Maven Projects

![image-20221110003857269](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211100038310.png)

现在已经下载到本地了，那么该怎么证明你的 Java 项目 在用 它呢？

![image-20221110004337252](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211100043313.png)

![image-20221110004359342](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211100043386.png)

### 四、实现效果

在maven里面开发 servlet，需要新建项目

1. main ---> new ---> Directory ---> java

2. 刷新下 Maven，Crete New Servlet ![image-20221110161513517](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101615556.png)

3. 静态资源放在 webapp 目录下

4. 在 llq 下新建一个包 utils，将 string ---> int

   ```java
   package com.aclq.utils;
   
   /**
    * @Author: Ronnie LEE
    * @Date: 2022/11/10 - 11 - 10 - 11:40
    * @Description: com.llq.utils
    * @version: 1.0
    */
   public class WebUtils {
       /**
        * 将一个字符串数字，转成int，如果转换失败，就返回自己传入的 defaultVal
        * @param str
        * @param defaultVal
        * @return
        */
       public static int parseInt(String str, int defaultVal){
           try {
               return Integer.parseInt(str);
           } catch (NumberFormatException e) {
               System.out.println(str + "格式不对，转换失败");
           }
           return  defaultVal;
       }
   }
   
   ```

   

5. 配置 Tomcat

   - 注意：新配置 tomcat 时，选择 ➕ 进行添加

     ![image-20221110144326971](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101443015.png)

   - add Configuration ---> Tomcat Server ---> Local ---> F:\apache-tomcat-8.0.50
   - Deployment ---> Artifact ---> llq_tomcat:war exploded
   - Application context只保留：/![image-20221110115947669](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/LeetCode/202211101159750.png)

   - 配置热加载





## Java_EE

### 1. 给浏览器返回信息

乱码问题解决：

```java
request.setCharacterEncoding("utf-8");   
 
response.setContentType("text/html;charset=utf-8");
```



```java
//  给浏览器返回信息
response.setContentType("text/html;charset=utf-8");
PrintWriter writer = response.getWriter();
writer.println("<h1>完成读取 cookie信息任务</h1>");
writer.flush();
writer.close();
```

### 2. login.html 登录界面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
</head>
<body>
<form action="/cs/loginCheck">
    <h1>用户登录界面</h1>
    用户名：<input type="text" name="username"></br></br>
    密码：<input type="password" name="password"></br></br>
    <input type="submit" value="登录">
	评论：<br><textarea name="review" style="width: 300px; height: 100px;"></textarea>
</form>
</body>
</html>
```

- 当 type="text" 时，name 的值就是：key，我们输入的值为：value
- 当 type="password" 时，输入的为星号
  - key: password
  - value：我们输入的值

- 当 type="summit"时，我们只能点击提交（不能输入），所以只有 value（显示的文字）



### 3. console.log()

```js
//	如果使用 + 的话，代表着字符串拼接
//	使用逗号可以看到具体的对象信息
console.log("xhr= ", xhr)
```





### 4. DOM绑定

#### 4.1 静态绑定

通过html 标签的 <font color="yellow">事件属性 </font>直接赋于事件响应后的代码，这种方式叫静态注册

#### 4.2 动态绑定

widows.onload() 作用

- window.onload() 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。
- window.onload() 通常用于 元素，在页面完全载入后(包括图片、css文件等等)执行脚本代码。

##### 为什么使用 windows.onload()?

因为 JavaScript 中的函数方法需要<在 HTML 文档渲染完成后才可以使用，如果没有渲染完成，此时的 <font color="yellow">DOM 树是不完整 </font>的，这样在调用一些 JavaScript 代码时就可能报出"undefined"错误。

我们都知道页面的代码顺序是 <font color="red">从上往下</font> 进行加载，很多时候我们要对页面中的某一个模块进行操作，这时候我们常常使用javascript代码来进行操作。为了能够保证操作的模块或对象在js代码之前就加载了，我们不得不把js代码放在页面的底端。

但是我们在设计页面的时候，为了把js代码放在一起，或者一个让页面更加简洁的位置，那就有可能出现代码中操作的对象未被加载的情况，那么我们该如何去解决呢？这时候 <font color="yellow">window.onload</font> 就被有了存在的意义了。

##### windows.onload 是什么?

window.onload是一个 <font color="yellow">事件</font>，在文档加载完成后能立即触发，并且能够为该事件注册事件处理函数。将要对对象或者模块进行操作的代码存放在处理函数中。即：window.onload =function (){这里写操作的代码};

##### 例子

###### 1. 对对象操作，但是对象未被加载，操作失败

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">

    document.getElementById("s").style.color = "green";

    </script>
</head>
<body>

<span id="s">ACLQ！！！</span>
</body>
</html>
```

![image-20221228110202955](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212281102080.png)

###### 2. 使用 windows.onload() 方法处理

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function(){
            document.getElementById("s").style.color = "red";
        }

    </script>
</head>
<body>

<span id="s"> ACLQ！！！</span>
</body>
</html>
```

![image-20221228110729412](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212281107466.png)

### 5. 将 login.html 改造成 servlet

因为 login.html 没有办法动态地去获取 value 值，所以要改造成 Servlet

- UserUIServlet：负责界面
- Login：信息校验
  - 接收用户输入
  - 判断该用户是否合法
  - 并返回提示信息

##### UserUISerlvet：负责界面

```java
/**
 * 界面
 */
public class UserUIServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("userUI 被访问! ");
        //  得到 writer
        response.setContentType("text/html;charset=utf-8");
        PrintWriter writer = response.getWriter();
        writer.println("<!DOCTYPE html>\n" +
                "<html lang=\"en\">\n" +
                "<head>\n" +
                "    <meta charset=\"UTF-8\">\n" +
                "    <title>登录</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "<form action=\"/cs/login\">\n" +
                "    <h1>用户登录界面</h1>\n" +
                "    用户名：<input type=\"text\" name=\"username\"></br></br>\n" +
                "    密码：<input type=\"text\" name=\"password\"></br></br>\n" +
                "    <input type=\"submit\" value=\"登录\">\n" +
                "</form>\n" +
                "</body>\n" +
                "</html>");
        writer.flush();
        writer.close();
    }


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doPost(request, response);
    }
}
```

##### LoginServlet 验证回送 Cookie

```java
//	验证，并给 浏览器传送 cookie
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //   1. 判断是否登录成功?
        String username = request.getParameter("username");
        String password = request.getParameter("password");

        response.setContentType("text/html;charset=utf-8");
        PrintWriter writer = response.getWriter();
        if (username != null && password != null){
            if ("llq".equals(username) && ("123456".equals(password))){
                //  将登录信息成功的用户名，以 cookie 形式，保存到浏览器

                Cookie cookie = new Cookie("username", "llq");
                cookie.setMaxAge(60 * 60 * 24 * 3); //  3 天后失效
                response.addCookie(cookie);
                //  给浏览器返回信息
                writer.println("<h1>恭喜你，登录成功</h1>");
            }else {
                //  给浏览器返回信息
                writer.println("<h1>用户或者密码信息不对，请重试！</h1>");
            }
            writer.flush();
            writer.close();
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doPost(request, response);
    }
}

```

然后，浏览器再次访问登录页面 UI 的时候，要读取 cookie

正常value格式：
```java
value = "xxx";
```

如果直接这么写，相当于双引号没有了

```java
value=xxx
```

```java
"    用户名：<input type=\"text\" name=\"username\"></br></br>\n" +
```

要改为：

```java
"    用户名：<input type=\"text\" value=\"" + value + "\"name=\"username\"></br></br>\n" +
```

```java
\"：引号转义符
```

![image-20221204200147456](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212042001548.png)

在一堆混乱的字符中插入一个变量：

- 中间截断：插入2个粉色引号
- 由于 value = "×××" 形式
- 使用 / " 进行转义

##### UserUIServlet：浏览器再次访问登录页面 UI 的时候，要读取 cookie

```java
public class UserUIServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("userUI 被访问! ");

        //  读取从浏览器发送来的 cookie
        Cookie[] cookies = request.getCookies();
        Cookie username = CookieUtils.readCookieByName("username", cookies);
        String value = "";
        if (username != null){
            value = username.getValue(); //  取出登录成功的名字
            System.out.println(value);
        }


        //  得到 writer
        response.setContentType("text/html;charset=utf-8");
        PrintWriter writer = response.getWriter();
        writer.println("<!DOCTYPE html>\n" +
                "<html lang=\"en\">\n" +
                "<head>\n" +
                "    <meta charset=\"UTF-8\">\n" +
                "    <title>登录</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "<form action=\"/cs/login\">\n" +
                "    <h1>用户登录界面</h1>\n" +
                "    用户名：<input type=\"text\" value=\"" + value + "\"name=\"username\"></br></br>\n" +
                "    密码：<input type=\"text\" name=\"password\"></br></br>\n" +
                "    <input type=\"submit\" value=\"登录\">\n" +
                "</form>\n" +
                "</body>\n" +
                "</html>");
        writer.flush();
        writer.close();

        RequestDispatcher requestDispatcher = request.getRequestDispatcher("/cs/login");
        requestDispatcher.forward(request, response);
    }


    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doPost(request, response);
    }
}

```



### 6. Servlet

#### 动态绑定(方法有，属性没有)

注意：

1. 当调用对象的<font color="yellow">方法</font>时，该方法会和对象的 内存地址 / <font color="yellow">运行类型</font> 绑定
2. 当调用对象的属性时，没有动态绑定机制，哪里声明，哪里使用

![image-20221217152242582](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171522684.png)

#### 6.1 ServletConfig

![image-20221217170132335](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171701439.png)

```java
   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       //	这个 servletConfig 对象是由 Tomcat创建的
        ServletConfig servletConfig = getServletConfig();
        String username = servletConfig.getInitParameter("username");
        String pwd = servletConfig.getInitParameter("pwd");
        System.out.println("初始化参数 user = " + username);
        System.out.println("初始化参数 pwd = " + pwd);
    }
```



![image-20221217150758505](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171507628.png)

1. Servlet程序默认是第1次访问的时候创建

2. ServletConfig 在 Servlet 程序创建时，就创建一个对应的 ServeltConfig 对象

   ![image-20221217150926248](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171509405.png)

 看到，父类 GenericServlet中有 getServletConfig() 方法

![image-20221217151026158](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212171510346.png)

```java
//	GenericServlet中的 ServletConfig config字段，用于保存 tomcat创建的 ServletConfig 对象
private transient ServletConfig config;
```

```java
//	getServletConfig() 方法，获取 ServletConfig config 字段
public ServletConfig getServletConfig() {
    return this.config;	//	返回当前类的 config 属性【属性没有动态绑定】
}
```

前面说了，当浏览器访问时 Serlvet时

- tomcat通过反射机制，实例化Serlvet
- 再创建一个对应的 ServeltConfig 对象

##### init（ServletConfig config）方法

通过该方法，将 Tomcat 创建的 ServletConfig 对象赋值给 GenericServlet 的 config 属性

```java
public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
```

最后 通过 getServletConfig() 方法，获取 config 字段 ===> 就是 Tomcat 创建的 ServletConfig 对象

- 体现了 <font color="yellow">封装性</font>。

注意，如果在 Servlet 中重写了 init(ServletConfig config)方法的话，要调用 super.init(ServletConfig config)方法，实现将 Tomcat创建的ServletConfig对象赋值给 GenericServlet 中的config字段，否则通过 getServletConfig() 方法获取到的 config字段就一直为 null。

```java
//	将 Tomcat 创建的 ServletConfig 对象给到了 GenreciServlet 里面的 config 属性
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);	//	中间桥梁作用
}
```

#### 6.2 ServletContext

![image-20221217235429764](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212172354898.png)

1. ServletContext 是一个接口，它表示 Servlet 上下文对象

2. 一个 web 工程，只有一个 ServletContext 对象实例

3. ServletContext 对象是在 web 工程启动的时候创建，在 web工程停止时销毁

4. ServletContext对象获取方式：

   - ServletConfig.getServeltContext() 方法获得对 ServletContext 对象的引用

   - 通过 this.getServletContext() 来获得其对象的引用

     ![image-20221217235635496](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212172356624.png)

   ![image-20221218001523685](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212180015959.png)

5. 由于一个 Web应用中的所有 Servlet 共享同一个 ServletContext 对象

   - 因此 Servlet 对象之间可以通过 ServletContext 对象来实现多个 Servlet 间通讯

   - ServletContext对象通常也被称之为域对象

     ![image-20221217235928547](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212172359714.png)

##### ServletContext 可以做什么

```java
 ServletContext servletContext = getServletContext();
```

1. 获取 web.xml 中配置的上下文参数 <font color="yellow"> context-param</font> 【信息和 <font color="red"> 整个web 应用</font> 相关，而不是属于某个 Servlet】

   ```java
   //  2. 获取 website
   String website = servletContext.getInitParameter("website");
   String company = servletContext.getInitParameter("company");
   System.out.println("website= " + website + "\n" + "company= " + company);
   ```

2. 获取当前的<font color="yellow"> 工程路径</font> ，格式：/ 工程路径 ===> 比如：/serlvet

   ```java
   //  3. 获取项目的工程路径
   String contextPath = servletContext.getContextPath();
   System.out.println("项目路径：" + contextPath);  //  /servlet
   ```

3. 获取工程部署后在服务器硬盘上的<font color="yellow"> 绝对路径</font>（更好地去定位资源），比如：

   ```java
   //  4. 获取项目发布后真正的工作路径
   //  / 表示我们的项目（发布后）的根路径
   //  E:\Tom\servlet\out\artifacts\servlet_war_exploded
   String realPath = servletContext.getRealPath("/");
   System.out.println("项目发布后的结对路径= " + realPath);
   ```

   ![image-20221218000955494](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212180009634.png)

4. 像 Map 一样存取数据，多个 Servlet 共享数据

### 7. cookie处理

#### 查找

```java
//	查找
public class CookieUtils {

    //  编写一个方法，返回指定名字的 cookie 值
    public static Cookie readCookieByName(String name, Cookie[] cookies){
        //  判断传入的参数是否正确
        if (name == null || "".equals(name) || cookies == null || cookies.length == 0){
            return null;
        }
        for (Cookie cookie : cookies) {
            if (name.equals(cookie.getName())){ //  如果名字相同
                return cookie;
            }
        }
        //  如果遍历完了之后，还是没有，就返回 null
        return null;
    }
}
```

#### 修改

```java
//	修改
public class UpdateCookie {
    public static Cookie updateCookieByName(String name, Cookie[] cookies){
        if (name == null || "".equals(name) || cookies == null || cookies.length == 0){
            return null;
        }
        for (Cookie cookie : cookies) {
            if (name.equals(cookie.getName())) {
                cookie.setValue("hiLLQ");
                return cookie;
            }
        }
        return null;
    }
}

//	注意：如果希望我们的浏览器本地的 cookie 也修改，则需要使用
if (cookie != null){
    response.addCookie(cookie);
}
```

#### 中文处理

存放中文 cookie，默认报错，可以通过 url 编码和解码来解决，不建议存放中文 cookie 信息

```java
public class EncoderCookie extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("encoder 被调用");
        Cookie cookie = new Cookie("name", "爱新觉罗LQ");
        response.addCookie(cookie);
        //  给浏览器返回信息
        response.setContentType("text/html;charset=utf-8");
        PrintWriter writer = response.getWriter();
        writer.println("<h1>设置中文 cookie 成功</h1>");
        writer.flush();
        writer.close();
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doPost(request, response);
    }
}

```

![image-20221205105031591](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212051050175.png)

##### URL 编码

- 如果直接存放中文的 cookie，会报错

  ```java
  //	报错
  HTTP Status 500 - Control character in cookie value or attribute.
  ```

- 解决方法：将中文 编成 URL 编码

  ```java
  // URLEncoder 工具类
  ```

  将 中文 转成一个 基于 utf-8 的 url 编码

  ```java
  String aclq = URLEncoder.encode("爱新觉罗LQ", "utf-8");
  Cookie cookie = new Cookie("name", aclq);
  ```

- 编码后，再保存即可

  ![image-20221205110105358](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212051101459.png)

```bash
Set-Cookie: name=%E7%88%B1%E6%96%B0%E8%A7%89%E7%BD%97LQ
```

使用工具可以来进行解码

![image-20221205110313543](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212051103654.png)

##### URL 解码

在读取 中文 cookie 时，进行解码

```java
public class ReadCookie2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("read2 被调用");
        Cookie[] cookies = request.getCookies();
        Cookie name = CookieUtils.readCookieByName("name", cookies);
        String value = name.getValue();
        //  解码
        String decode = URLDecoder.decode(value, "utf-8");
        System.out.println("解码后的 value= " + decode);

        //  给浏览器返回信息
        response.setContentType("text/html;charset=utf-8");
        PrintWriter writer = response.getWriter();
        writer.println("<h1>完成读取中文 cookie信息 解码成功</h1>");
        writer.flush();
        writer.close();

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doPost(request, response);
    }
}
```

### 8. jsp简易计算器（JS + 正则表达式）

用户可以提交数据，并完成校验

通过 id 来获取元素，再通过 .value 取出对应值

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>jsp版本计算器</title>
    <%--使用 js + 正则表达式完成数据校验--%>
    <script type="text/javascript">
        function check() {
            //  得到 num1 和 num2的值
            let num1 = document.getElementById("num1").value;
            let num2 = document.getElementById("num2").value;

            //  验证：正则表达式
            let reg = /^[-]?([1-9]\d*|0)$/;
            if (!reg.test(num1)){ // 如果不满足验证体哦阿健
                alert("num1 不是一个整数");
                return false;   //  我就不提交了
            }
            if (!reg.test(num2)){
                alert("num2 不是一个整数");
                return false;
            }
            return true;
        }
    </script>
</head>
<body>
<h1>jsp版本-计算器</h1>
<form action="/jsp/cal_server.jsp" onsubmit="return check()">
    num1：<input type="text" id="num1" name="num1"><br/><br/>
    num2: <input type="text" id="num2" name="num2"><br/><br/>

    运算符号:
    <select name="symbol">
        <option>--选择--</option>
        <option selected value="+">+</option>
        <option value="-">-</option>
        <option value="*">*</option>
        <option value="/">/</option>
     </select><br/><br/>
     <input type="submit" value="计算">
</form>

</body>
</html>
```

### 9. EL表达式 （替代 jsp表达式<%=表达式%>）

本质：语法糖

- EL表达式在 输出 null 时，输出的是 ""
- jsp 表达式脚本输出 null 时，输出的是 "null" 字符串

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>el表达式快速入门</title>
</head>
<body>
<%--
    解读：
    1.  如果 name 是 null，request.getAttribute() 返回的是 null 字符串 【显示有些难看】
    2.  如果 name 是 ${name} 返回的是 ""
    //  进一步理解：相当于
    <%request.getAttribute("name") == null? "" : request.getAttribute("name")%>
--%>

<%
    request.setAttribute("name", "爱新觉罗LQ");
%>
<h1>jsp 表达式脚本</h1>
名字= <%=request.getAttribute("name")%><br>
<h1>el 表达式</h1>
名字= ${name}<br>
</body>
</html>
```

作业优化：

```jsp
<%--
  Created by IntelliJ IDEA.
  User: 李隆齐
  Date: 2022/12/8
  Version: 1.0
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>jsp版本计算器</title>
    <%--使用 js + 正则表达式完成数据校验--%>
    <script type="text/javascript">
        function check() {
            //  得到 num1 和 num2的值
            let num1 = document.getElementById("num1").value;
            let num2 = document.getElementById("num2").value;

            //  验证：正则表达式
            let reg = /^[-]?([1-9]\d*|0)$/;
            if (!reg.test(num1)){ // 如果不满足验证体哦阿健
                alert("num1 不是一个整数");
                return false;   //  我就不提交了
            }
            if (!reg.test(num2)){
                alert("num2 不是一个整数");
                return false;
            }
            return true;
        }
    </script>
</head>
<body>

<h1>jsp版本-计算器</h1>
<form action="/jsp/calServlet" onsubmit="return check()">
    num1：<input type="text" id="num1" name="num1">${num1_error}<br/><br/>
    num2: <input type="text" id="num2" name="num2">${num2_error}<br/><br/>

    运算符号:${symbol_error}
    <select name="symbol">
        <option>--选择--</option>
        <option selected value="+">+</option>
        <option value="-">-</option>
        <option value="*">*</option>
        <option value="/">/</option>
     </select><br/><br/>
     <input type="submit" value="计算">
</form>

</body>
</html>
```



### 10. 通过 Reploy 来清掉 Session

![image-20221215005517077](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212150055179.png)

![image-20221215005545177](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212150055252.png)

### 11. jstl（替代jsp的代码脚本<%%>） 实现表格展示

使用 forEach 循环获取

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>展示</title>
</head>
<body>
<h1>展示</h1>
<table border="1px" width="400px">
    <tr>
        <td>id</td>
        <td>name</td>
        <td>skill</td>	
    </tr>
    <c:forEach items="${requestScope.monster}" var="guaiwu">
        <c:if test="${guaiwu.id > 100}">
            <tr>
                <td>${guaiwu.id}</td>
                <td>${guaiwu.name}</td>
                <td>${guaiwu.job}</td>
            </tr>
        </c:if>
    </c:forEach>
</table>
</body>
</html>
```

### 12. 时间戳

```java
public class WebUtils {
    public static String getYearMonthDay(){
        // 3代日期类
        LocalDateTime now = LocalDateTime.now();
        int year = now.getYear();
        int monthValue = now.getMonthValue();
        int dayOfMonth = now.getDayOfMonth();
        String yearMonthDay = year + "/" + monthValue + "/" + dayOfMonth;
        return yearMonthDay;
    }
}
```

### 13. JS 正则表达式 【前端校验】

在JavaScript当中，声明一个正则表达式对象的方式有两种。

一种是直接声明RegExp对象，一种是使用 <font color="yellow">字面量</font>。

```java
var rExp1 = new RegExp("\\d+");
var rExp2 = /\d+/;
//以上是等价的。
```

### 14. Web项目中 properties 路径问题

因为是 web 项目，它的工作目录在 out，文件的加载使用类加载器，找到我们的工作目录

```java
package com.alq.fruns.utils;
/**
 * 基于 Druid 数据库连接池的工具类
 */
public class JDBCUtilsByDruid {
    private static DataSource ds;

    //  在静态代码块中完成 ds 初始化
    static {
        //  1. 加入 Druid jar 包
        //  2. 加入 配置文件，将该文件拷贝到项目的 src 目录
        //  3. 创建 Properties 对象，读取配置文件
        Properties properties = new Properties();
        try {
            //  因为是 web 项目，它的工作目录在 out，文件的加载使用类加载器
            //  找到我们的工作目录
            properties.load(JDBCUtilsByDruid.class.getClassLoader().getResourceAsStream("druid.properties"));
            // properties.load(new FileInputStream("src/druid.properties"));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 15. JavaWeb Debug 技巧

![image-20230209105941450](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302091059762.png)

### 16. 建表注意事项

int(11) ---> 位数设置成11 是有道理的

- 因为 int 是4个字节，如果是无符号的话，最多可以表示 $2^{32} - 1=$ 4294967295 【10位】
- 如果是负数的话，那么符号也算一位，所以共 10 + 1 = 11 位

```sql
# 有时候会看到 id int(11) ... 11 表示的显示宽度，配置 ZEROFILL
#									int(2) ... 2 表示的也是显示宽度
# 存放的数据范围是一样的【范围仅和 int 相关】
# 67890 ===> int(11) 00000067890
# 67890 ===> int(2) 67890
CREATE TABLE `furn`(
	`id` INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, # UNSIGNED 存放的数据大些，不需要负数
	`name` VARCHAR(64) UNIQUE KEY,
	`maker` VARCHAR(64) not NULL,	# 制造商
	`price` DECIMAL(11, 2) not NULL,	# 价格（定点数）
	`sales` INT UNSIGNED not NULL,	# 销量
	`stock` INT UNSIGNED not NULL,	# 库存
	`img_path` VARCHAR(256) NOT NULL	# 存放图片路径
) CHARSET utf8 ENGINE INNODB
```

### 17. entity 字段和 数据库中不一致的情况

解决方法：修改 sql 语句（起个别名）

以后 SSM 中的注解的原理和这个是类似的

- 反射：是根据查回来的字段，去找 javaBean 中对应的属性【如果不一致，就会映射失败】

```java
String sql = "select `id`, `name`, `maker`, `price`, `sales`, `stock`, `img_path` imgPath from furn";
```

### 18. base 标签添加

```html
<base href="<%=request.getContextPath() + "/"%>">
```

### 19. hidden 标签添加【action】

```html
<input type="hidden" name="action" value="login"/>
```

### 20. 前端错误信息提示【EL 表达式】

```html
<%--提示错误信息--%>
<span style="font-size: 18pt;font-weight: bold;float:right;color: red">
    ${requestScope.err_msg}
</span>
    
<!--El 表达式-->
<input type="text" name="username" value="${requestScope.username}" placeholder="Username"/>
```

### 21. 前端校验【在 head 中添加】

思路分析：

1. 使用jquery+正则表达式即可
2. 绑定事件，按要求验证，如果有错误，给出提示信息(不要用弹窗)

```js
<!--引入 jQuery-->
<script type="text/javascript" src="../../script/jquery-3.6.0.min.js"></script>
<script type="text/javascript">
    $(function () { //  页面加载完毕后执行 function
    //  绑定点击事件
    $("#sub-btn").click(function () {
        //  获取到输入的用户名
        var userNameval = $("#username").val();
        //  编写正则表达式来验证
        var userNamePattern = /^\w{6,10}$/;
        //  验证
        if (!userNamePattern.test(userNameval)){
            //  展示错误提示 【jQuery 属性过滤器】
            $("span[class=errorMsg]").text("用户名格式不对，需要 6 - 10 个字符");
            return false; //  不提交
        }

        //  完成对密码的校验
        var passWordVal = $("#password").val();
        if (!userNamePattern.test(passWordVal)){
            //  密码错误提示 --- 【jQuery 基本选择器】
            $("span.errorMsg").text("密码格式不对，需要 6 - 10 个字符");
            return false; //  不提交
        }

        //  2次数密码相同
        var rePwdVal = $("#repwd").val();
        if (rePwdVal != passWordVal){
            $("span.errorMsg").text("输入的 2 次密码不相同");
            return false;
        }

        //  验证邮箱
        var emailVal = $("#email").val();
        //  在 java 中，正则表达式的转义是 \\，在 js 中是 \
        var emailValPattern = /^[\w-]+@([a-zA-Z]+\.)+(com|cn)$/;
        if (!emailValPattern.test(emailVal)){
            $("span.errorMsg").text("电子邮件格式不正确，请重新输入");
            return false;
        }

        //  过五关斩六将成功 ---> 我们暂时不提交，显示验证通过！！！【后端还没写】
        $("span.errorMsg").text("验证通过");
        return false;
    })
})
</script>
```

```html
<tr>
    <td class="product-thumbnail">
        <a href="#"><img class="img-responsive ml-3" src="assets/images/product-image/default.jpg"
alt=""/></a>
</td>
<td class="product-name"><input name="name" style="width: 60%" type="text" value="Name"/></td>
<td class="product-name"><input name="maker" style="width: 90%" type="text" value="蚂蚁家居"/></td>
<td class="product-price-cart"><input name="price" style="width: 90%" type="text" value="60.00"/></td>
<td class="product-quantity">
    <input name="sales" style="width: 90%" type="text" value="100"/>
        </td>
<td class="product-quantity">
    <input name="stock" style="width: 90%" type="text" value="80"/>
        </td>
<td>
        <!--                                    <a href="#"><i class="icon-pencil"></i></a>-->
        <!--                                    <a href="#"><i class="icon-close"></i></a>-->
        <input id="login-btn" type="submit" style="width: 90%;background-color: silver;border: silver;border-radius: 20%;" value="添加家居"/>
            </td>
</tr>
```

### 22. 工具类DataUtils(底层使用（BeanUtils） 来完成自动封装JavaBean【⭐】

右键 ---> Evaluate Expression

![image-20230212000523929](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302120005132.png)

使用反射（通过 class 对象访问 属性）将数据封装，有一个前提是：表单提交的数据字段名

要和封装的 JavaBean的 属性名一致 【利用 map 通过 furn 全参数构造器，来构建一个对象】

- 先通过无参构建器，获取一个 Furn 对象
- 再通过 set 方法 进行填充 

![image-20230212002122180](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302120021460.png)

```java
@Override
public boolean addFurns(Furn furn) {
    //	img_path 为 null
    String sql = "insert into furn(`id`, `name`, `maker`, `price`, `sales`, `stock`, `img_path`)  values(?,?,?,?,?,?,?)";
    int afffectedRows = update(sql, null, furn.getName(), furn.getMaker(), furn.getPrice(), furn.getSales(), furn.getStock(), furn.getImgPath());
    return afffectedRows > 0;
}
```

```sql
# 有时候会看到 id int(11) ... 11 表示的显示宽度，配置 ZEROFILL
#									int(2) ... 2 表示的也是显示宽度
# 存放的数据范围是一样的【范围仅和 int 相关】
# 67890 ===> int(11) 00000067890
# 67890 ===> int(2) 67890
CREATE TABLE `furn`(
	`id` INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, # UNSIGNED 存放的数据大些，不需要负数
	`name` VARCHAR(64) UNIQUE KEY,
	`maker` VARCHAR(64) not NULL,	# 制造商
	`price` DECIMAL(11, 2) not NULL,	# 价格（定点数）
	`sales` INT UNSIGNED not NULL,	# 销量
	`stock` INT UNSIGNED not NULL,	# 库存
	`img_path` VARCHAR(256) NOT NULL	# 存放图片路径
) CHARSET utf8 ENGINE INNODB
```

```java
Furn furn = new Furn();
try {
    //	populate 填充
    BeanUtils.populate(furn, req.getParameterMap());	//	第一个参数为 javabean
} catch (Exception e) {
    e.printStackTrace();
}
```

```java
public static void populate(Object bean, Map properties) throws IllegalAccessException, InvocationTargetException {
    BeanUtilsBean.getInstance().populate(bean, properties);
}
```

```java
public void populate(Object bean, Map properties) throws IllegalAccessException, InvocationTargetException {
    if (bean != null && properties != null) {
        if (this.log.isDebugEnabled()) {
            this.log.debug("BeanUtils.populate(" + bean + ", " + properties + ")");
        }

        Iterator entries = properties.entrySet().iterator();

        while(entries.hasNext()) {
            Entry entry = (Entry)entries.next();
            String name = (String)entry.getKey();
            if (name != null) {
                this.setProperty(bean, name, entry.getValue());
            }
        }
    }
}
```

```java
public void setProperty(Object bean, String name, Object value) throws IllegalAccessException, InvocationTargetException {
    if (this.log.isTraceEnabled()) {
        StringBuffer sb = new StringBuffer("  setProperty(");
        sb.append(bean);
        sb.append(", ");
        sb.append(name);
        sb.append(", ");
        if (value == null) {
            sb.append("<NULL>");
        } else if (value instanceof String) {
            sb.append((String)value);
        } else if (!(value instanceof String[])) {
            sb.append(value.toString());
        } else {
            String[] values = (String[])((String[])value);
            sb.append('[');

            for(int i = 0; i < values.length; ++i) {
                if (i > 0) {
                    sb.append(',');
                }

                sb.append(values[i]);
            }

            sb.append(']');
        }

        sb.append(')');
        this.log.trace(sb.toString());
    }

    Object target = bean;
    Resolver resolver = this.getPropertyUtils().getResolver();	

    while(resolver.hasNested(name)) {
        try {
            target = this.getPropertyUtils().getProperty(target, resolver.next(name));
            name = resolver.remove(name);
        } catch (NoSuchMethodException var14) {
            return;
        }
    }

    if (this.log.isTraceEnabled()) {
        this.log.trace("    Target bean = " + target);
        this.log.trace("    Target name = " + name);
    }

    String propName = resolver.getProperty(name);
    Class type = null;
    int index = resolver.getIndex(name);
    String key = resolver.getKey(name);
    DynaClass newValue;
    if (target instanceof DynaBean) {
        newValue = ((DynaBean)target).getDynaClass();
        DynaProperty dynaProperty = newValue.getDynaProperty(propName);
        if (dynaProperty == null) {
            return;
        }

        type = dynaProperty.getType();
    } else if (target instanceof Map) {
        type = class$java$lang$Object == null ? (class$java$lang$Object = class$("java.lang.Object")) : class$java$lang$Object;
    } else {
        newValue = null;

        PropertyDescriptor descriptor;
        try {
            descriptor = this.getPropertyUtils().getPropertyDescriptor(target, name);
            if (descriptor == null) {
                return;
            }
        } catch (NoSuchMethodException var13) {
            return;
        }

        if (descriptor instanceof MappedPropertyDescriptor) {
            if (((MappedPropertyDescriptor)descriptor).getMappedWriteMethod() == null) {
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Skipping read-only property");
                }

                return;
            }

            type = ((MappedPropertyDescriptor)descriptor).getMappedPropertyType();
        } else if (index >= 0 && descriptor instanceof IndexedPropertyDescriptor) {
            if (((IndexedPropertyDescriptor)descriptor).getIndexedWriteMethod() == null) {
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Skipping read-only property");
                }

                return;
            }

            type = ((IndexedPropertyDescriptor)descriptor).getIndexedPropertyType();
        } else if (key != null) {
            if (descriptor.getReadMethod() == null) {
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Skipping read-only property");
                }

                return;
            }

            type = value == null ? (class$java$lang$Object == null ? (class$java$lang$Object = class$("java.lang.Object")) : class$java$lang$Object) : value.getClass();
        } else {
            if (descriptor.getWriteMethod() == null) {
                if (this.log.isDebugEnabled()) {
                    this.log.debug("Skipping read-only property");
                }

                return;
            }

            type = descriptor.getPropertyType();
        }
    }

    newValue = null;
    Object newValue;
    if (type.isArray() && index < 0) {
        if (value == null) {
            String[] values = new String[]{(String)value};
            newValue = this.getConvertUtils().convert((String[])values, type);
        } else if (value instanceof String) {
            newValue = this.getConvertUtils().convert(value, type);
        } else if (value instanceof String[]) {
            newValue = this.getConvertUtils().convert((String[])((String[])value), type);
        } else {
            newValue = this.convert(value, type);
        }
    } else if (type.isArray()) {
        if (!(value instanceof String) && value != null) {
            if (value instanceof String[]) {
                newValue = this.getConvertUtils().convert(((String[])((String[])value))[0], type.getComponentType());
            } else {
                newValue = this.convert(value, type.getComponentType());
            }
        } else {
            newValue = this.getConvertUtils().convert((String)value, type.getComponentType());	
        }
    } else if (!(value instanceof String) && value != null) {
        if (value instanceof String[]) {
            newValue = this.getConvertUtils().convert(((String[])((String[])value))[0], type);
        } else {
            newValue = this.convert(value, type);
        }
    } else {
        newValue = this.getConvertUtils().convert((String)value, type);
    }

    try {
        this.getPropertyUtils().setProperty(target, name, newValue);	
    } catch (NoSuchMethodException var12) {
        throw new InvocationTargetException(var12, "Cannot set " + propName);
    }
}
```

解决方式：

1. 利用 set 方法，手动输入 ImgPath 字段

2. 由于底层仍然是要构造一个 Furn

   - 修改构造器

     ```java
     private String imgPath = "assets/images/product-image/default.jpg";
     
     public Furn() {
     }
     
     public Furn(Integer id, String name, String maker, BigDecimal price, Integer sales, Integer stock, String imgPath) {
         this.id = id;
         this.name = name;
         this.maker = maker;
         this.price = price;
         this.sales = sales;
         this.stock = stock;
         if(!(imgPath == null || "".equals(imgPath))) {
             this.imgPath = imgPath;
         }
     }
     ```

     这样在构建 Furn 对象的时候，就会有一个默认值，那么在底层添加的时候，它 get 的时候，就不会 get 到一个 null 了

最后整合成一个工具类

```java
package com.alq.fruns.utils;

public class DataUtils {

    //将方法，封装到静态方法，方便使用
    public static <T> T copyParamToBean(Map value, T bean) {	//	不管是什么 bean，我都可以进行填充
        try {
            BeanUtils.populate(bean, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

整合代码

```java
//  自动将提交的数据，封装到 Furn 对象中
//  key：字段
//  value：值
Furn furn = DataUtils.copyParamToBean(req.getParameterMap(), new Furn());
furnService.add(furn);
resp.sendRedirect(req.getContextPath() + "/manage/furnServlet?action=list");	//	重定向【防止重复提交请求】
```

### 23. post 提交时候不能使用？的方式来传入参数 ---> 使用隐藏域 hidden 解决

```html
<input type="hidden" name="action" value="update"/>
<input type="hidden" name="id" value="${requestScope.furn.id}"/>
```

### 24. 获取 表的行数

```java
//	所有数据类型都可以向上转型成 Number【queryScalr 返回类型是 long】
@Override
public int getTotalRow() {
    String sql = "select count(*) from furn";
    return ((Number)queryScalar(sql)).intValue();
}
```

### 25. 分页

```java
public Page<Furn> page(int pageNo, int pageSize) {
    //  先创建一个 Page 对象，然后根据实际情况填充属性
    int totalRow = furnDAO.getTotalRow();   //  行数、
    Page<Furn> page = new Page<>();
    page.setPageNo(pageNo);
    page.setPageSize(pageSize);
    page.setPageTotalRow(totalRow);
    //  pageTotalCount 通过计算得到 ---> 一个小小的算法实现
    int pageTotalCount = totalRow / pageSize;   //  页数
    if (totalRow % pageSize > 0){
        pageTotalCount += 1;
    }
    page.setPageTotalCount(pageTotalCount);

    int begin = (pageNo - 1) * pageSize;
    List<Furn> pageItems = furnDAO.getPageItems(begin, pageSize);
    page.setItems(pageItems);
    //  还差一个 url，分页导航，先放一放
    return page;
}
```

前端分页界面

```html
<!--  Pagination【fenye】 Area Start -->
<div class="pro-pagination-style text-center mb-md-30px mb-lm-30px mt-6" data-aos="fade-up">
    <ul>
        <li><a href="#">首页</a></li>
        <li><a href="#">上页</a></li>
        <li><a class="active" href="#">3</a></li>
        <li><a href="#">4</a></li>
        <li><a href="#">5</a></li>
        <li><a href="#">下页</a></li>
        <li><a href="#">末页</a></li>
        <li><a>共10页</a></li>
        <li><a>共90记录</a></li>
    </ul>
</div>
<!--  Pagination Area End -->
```

#### jstl 表达式 \<c:if>

利用 jstl 中 \<c:if> 表达式 来进行限制当前页码大于等于1，小于等于总页数时候，才会进行显示

```jsp
<!--  Pagination Area Start -->
<div class="pro-pagination-style text-center mb-md-30px mb-lm-30px mt-6" data-aos="fade-up">
    <ul>
        <%--如果当前页 > 1，就显示上一页（跳转）--%>
        <c:if test="${requestScope.page.pageNo > 1}">
            <li><a href="manage/furnServlet?action=page&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
        </c:if>

        <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
            <li><a href="manage/furnServlet?action=page&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
        </c:if>
    </ul>
</div>
<!--  Pagination Area End -->
```

显示所有的分页页面

#### jstl 表达式 \<c:foreach>

c:forEach 标签用来 遍历输出, 主要有4 种形式

##### 普通遍历

```html
<h1>普通遍历</h1>
<h1>c:forEach 标签</h1>
<ul>
    <c:forEach begin="1" step="2" end="5" var="i">
        <li>排名${i}</li>
    </c:forEach>
</ul>
```

##### 遍历数组

```html
<h1>第2种遍历方式：遍历数组</h1>
<%
    request.setAttribute("sports", new String[]{"打篮球", "乒乓球"});
%>
<c:forEach items="${requestScope.sports}" var="sport">
    运动名称=${sport}<br>
</c:forEach>
```

##### 遍历 Map

```html
<h1>第3种遍历方式：遍历Map</h1>
<%
    HashMap<String, Object> map = new HashMap<>();
    map.put("key1", "北京");
    map.put("key2", "上海");
    map.put("key3", "天津");
    request.setAttribute("cities", map);
%>
<c:forEach items="${requestScope.cities}" var="city">
    城市信息：${city.key}--${city.value}<br>
</c:forEach>
```

##### 遍历 List

```html
//	底层走的是 monster.getId() 方法
<h1>第4种遍历方式：遍历List</h1>
<%
    List<Monster> monsters = new ArrayList<>();
    monsters.add(new Monster(100, "小妖怪", "巡山的"));
    monsters.add(new Monster(200, "大妖怪", "做饭的"));
    monsters.add(new Monster(300, "老妖怪", "打扫卫生的"));

    request.setAttribute("monsters", monsters);
%>
<c:forEach items="${requestScope.monsters}" var="monster">
    妖怪的信息：${monster.id}--${monster.name}--${monster.skill}<br>
</c:forEach>
```

#### jstl 表达式 \<c:set>

```html
<c:set var="begin" value="1"/>
<c:set var="end" value="${requestScope.page.pageTotalCount}"/>
```

后续根据 begin 和  end，来进行显示个数的限制

### 26. EL 的 11个隐含对象，可以直接使用

| 变量             | 类型                 | 说明                            |
| ---------------- | -------------------- | ------------------------------- |
| pageContext      | PageContextlmpl      | 获取jsp中的九大内置对象         |
| pageScope        | Map<String,Object>   | 获取pageContext域中的数据       |
| requestScope     | Map<String,Object>   | 获取 Request域中的数据          |
| sessionScope     | Map<String,Object>   | 获取 Session域中的数据          |
| applicationScope | Map<String,Object>   | 获取 ServletContext 域中的数据  |
| param            | Map<String,String>   | 获取请求参数的值                |
| paramValues      | Map<String,String[]> | 获取多个值                      |
| header           | Map<String,String>   | 获取请求头的信息                |
| headerValues     | Map<String,String[]> | 获取请求头的多个信息            |
| cookie           | Map<String,Cookie>   | 获取当前请求的Cookie信息        |
| initParam        | Map<String,String>   | 获取在web.xml中配置的上下文参数 |



#### 如果页数很多，最多显示5个

### 27. JavaWeb Debug思考

可以先 Debug，然后点击跳转后，把断点拿掉！这样就可以正常运行了！【等在需要调试的时候，再把断点给加上！！！】

### 28. jsp 请求转发

```jsp
<jsp:forward page="?"></jsp:forward>
```

### 29. JavaWeb 项目启动执行的文件

1. index.html
2. index.htm
3. index.jsp

看下 Tomcat 中web.xml文件配置

```xml
<welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
</welcome-file-list>
```

### 30. queryScalar转换成 int

```java
((Number)(queryScalar(sql, name))).intValue()
```

### 31. jsp 文件为什么可以调用 request.getContextPath()

1. sum.jsp ---> sum_jsp.java
2. sum_jsp.java 继承了 HttpjspBase
   - HttpServlet【sum.jsp 本质就是 Servlet，所以可以用 request】
   - HttpJspPage 【同时拥有更强大的功能 out 对象等】

```java
//  对验证码图片进行绑定
$("#codeImg").click(function () {
    this.src = "<%=request.getContextPath() + "/"%>" + "kaptchaServlet";
})
```

### 32. Fuck!!!

![image-20230218211227970](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302182112098.png)

```html
   <span class="errorMsg"
         style="float: right; font-weight: bold; font-size: 20pt; margin-left: 10px;"></span>
```

```java
//  验证
if (!userNamePattern.test(userNameval)){
//  展示错误提示 【jQuery 属性过滤器】
$("span[class=errorMsg]").text("用户名格式不对，需要 6 - 10 个字符");
return false; //  不提交
}
```

将这个span 样式给删除了，我说他妈的怎么一直提交不了呢！！！

### 33. BigDecimal 乘法

```java
item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount())));
```

### 34. todo标识使用

![image-20230219120836425](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302191208695.png)

### 35. 验证 API（Servlet中的 具体方法）可以先用 url

```bash
http://localhost:8080/jiaju_mall/cartServlet?action=addItem&id=1
```

![image-20230219132331793](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302191323884.png)

### 36. jQuery 取出标签内的某个属性

```html
<button title="Add To Cart" furnId="${furn.id}" class="add-to-cart">Add	<!-- 使用标签来取出 id -->
    To Cart
</button>
```

```html
<%--引入 jQuery--%>
    <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
    <script>
        $(function () {
            //  给 add to cart 按钮绑定事件
            $("button[class=add-to-cart]").click(function () {
                //  获取到点击的 id
                var furnId = $(this).attr("furnId");
                alert(furnId);
            })
        })
    </script>
```

### 37. jQuery 点击跳转 URL【location.href】

```html
<%--引入 jQuery--%>
    <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
    <script>
        $(function () {
            //  给 add to cart 按钮绑定事件
            $("button[class=add-to-cart]").click(function () {
                //  获取到点击的 id
                var furnId = $(this).attr("furnId");
                //  发出一个请求，添加家居 ---> 后面用ajax
                location.href = "cartServlet?action=addItem&id=" + furnId;
            })
        })
    </script>
```

### 38. 前端无法跳转分析【find in path】

toggle：切换

```html
<a href="views/cart/cart.jsp"
   class="header-action-btn header-action-btn-cart offcanvas-toggle pr-0"> <!-- 注意toggle 标签 -->
    <i class="icon-handbag"> 购物车</i>
    <span class="header-action-num">${sessionScope.cart.totalCount}</span>
</a>
```

![image-20230220114530256](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302201145017.png)

```java
/*---------------------------------
        Off Canvas Function
    -----------------------------------*/
(function() {
    var $offCanvasToggle = $(".offcanvas-toggle"),
    $offCanvas = $(".offcanvas"),
    $offCanvasOverlay = $(".offcanvas-overlay"),
    $mobileMenuToggle = $(".mobile-menu-toggle");
    $offCanvasToggle.on("click", function(e) {
        e.preventDefault();	//	默认阻止
        var $this = $(this),
        $target = $this.attr("href");
        $body.addClass("offcanvas-open");
        $($target).addClass("offcanvas-open");
        $offCanvasOverlay.fadeIn();
        if ($this.parent().hasClass("mobile-menu-toggle")) {
            $this.addClass("close");
        }
    });
    $(".offcanvas-close, .offcanvas-overlay").on("click", function(e) {
        e.preventDefault();
        $body.removeClass("offcanvas-open");
        $offCanvas.removeClass("offcanvas-open");
        $offCanvasOverlay.fadeOut();
        $mobileMenuToggle.find("a").removeClass("close");
    });
})()
```

所以，先把这个拿掉！！！

- 通过分析：offcanvas-toogle 会在 main.js 中做处理，组织本身超链接跳转
- 所以我们可以将该 offcanvas-toogle 去掉，恢复超链接本身机制

### 39. confirm是否确认删除

```js
    <!--引入 jQuery-->
    <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
    <script type="text/javascript">
        $(function () { //  页面加载完毕后执行 function
        //  获取到要删除的家居的名字

        $("a[class='deleteCss']").click(function () {   //  class 属性选择器
            //  获取到输入的用户名
            alert("hello");
            //	eq(1)：代表 第 2 个
            var furnName = $(this).parent().parent().find("td:eq(1)").text(); //  当前点击的 a 标签对应的 jQuery 对象为： $(this)
            alert("furnName= " + furnName);
            //  老韩解读
            //  1. confirm 方法会弹出一个确认窗口
            //  2. 点击确定，返回 true
            //  3. 点击取消，返回 false
            return confirm("你确定删除 【" +  furnName + "】?");
        })
    })
    </script>
```

### 40. hashMap 本身提供了一个方法 clear

```java
map.clear();
```



### 41. Navicat 误关了窗口恢复

![image-20230222125917871](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302221259006.png)

### 42. 生成订单涉及多张表

生成订单会操作多表，因此会涉及到如下技术：

- 多表事务的问题 
- ThreadLocal
- Mysql 事务机制 
- 过滤器【Filter】

### 43. Arrays类将数组转成 list

```java
excludedUrlsList = Arrays.asList(split);    //  将数组直接转成 list
```

### 44. 获得 url 方式

```java
String url = request.getServletPath();
```

### 45. 异常处理机制【参与业务逻辑】

```java
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    try {
        //	解读，只有在 try 出现了异常，才会进行 catch 执行
        //	才会进行回滚
        filterChain.doFilter(servletRequest, servletResponse); 
        JDBCUtilsByDruid.commit();
    } catch (Exception e) {
        JDBCUtilsByDruid.rollback();
    }
}
```

![iioo](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202302281101285.png)

解决方法：在BasicServlet 中将异常抛出！！！

```java
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    req.setCharacterEncoding("utf-8");

    System.out.println("BasicServlet");
    String action = req.getParameter("action");
    System.out.println(action);
    //  使用反射，获取当前对象的方法
    //  老韩解读
    //  this 就是请求的 Servlet
    //  declaredMethod 方法对象就是当前请求的 servlet 对应的 action 名字 的方法，该方法对象（declaredMethod）
    //  是变化的，根据用户请求
    System.out.println(this);
    try {
        Method declaredMethod = //  方法对象
            this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);
        //  使用方法对象，进行反射调用
        declaredMethod.invoke(this, req, resp);

    } catch (Exception e) {
        //  将发生的异常继续 throw
        throw new RuntimeException(e);
    }
}
```

### 46. 统一错误页面【Filter是由 Tomcat 创建的，在 Filter中将异常抛出给 Tomcat】

1. 配置 xml

   ```xml
   <!--错误提示页面-->
   <error-page>
       <error-code>404</error-code>
       <location>/views/error/404.jsp</location>
   </error-page>
   <error-page>
       <error-code>500</error-code>
       <location>/views/error/500.jsp</location>
   </error-page>
   ```

2. 针对 500 错误进行处理

   ```java
   @Override
   public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
       try {
           filterChain.doFilter(servletRequest, servletResponse);  //  放行
           JDBCUtilsByDruid.commit();
       } catch (Exception e) {
           JDBCUtilsByDruid.rollback();
           e.printStackTrace();	//	回滚之后，知识将异常打印，没做其它任何事情，Tomcat不知道你有任何错误
       }
   }
   ```

   抛出异常给 Tomcat，tomcat 会根据 errorpage 来显示对应页面

### 47. 数据 ---> Map ---> Json

```java
protected void isExistUserName(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String username = request.getParameter("username");
    boolean isExistsUsername = memberService.isExistsUsername(username);
    //  采用 数据 ---> MAp ---> Json
    Map<String, Object> resultMap = new HashMap<>();
    resultMap.put("isExist", isExistsUsername);
    resultMap.put("email", "jack@qq.com");
    resultMap.put("job", "java工程师");
    String resultJson = new Gson().toJson(resultMap);	//	map ---> Json
    response.setContentType("text/html;charset=utf-8");
    response.getWriter().write(resultJson);
}
```

### 48. 整合前端

给用户名输入框绑定一个 blur 事件

方案1：

```js
$("#username").blur(function () {
    //  获取输入的用户名
    var username = $(this).val();
    //  ajax 发送请求 ---> jQuery
    $.getJSON("member",     //  url
              "action=isExistUserName&username=" + username,  //  请求的数据
              function (data) {   //  回调函数
        console.log("data=", data);
    })
})
```

方案2：【Json 作为实参】--- 看着更简洁

相当于 发送的 ajax请求，携带的数据是通过 json 对象放入

```js
$.getJSON("member", {   //  url
    "action": "isExistUserName",    //  请求的数据
    "username": username
},
          function (data){    //  回调函数
    console.log("data=", data);
})
```

### 49. 使用 ajax 过滤器失效，无法请求转发和重定向

1. 主要是服务器得到是ajax 发送过来的request,也就是说这个请求 <font color="yellow">不是浏览器请求 </font>的,而是ajax 请求的所以,servlet 对request 进行请求转发或重定向都 <font color="yellow">不能影响浏览器的跳转</font>
2. 这时出现请求转发和重定向失效的问题
3. 解决方案：如果想要实现跳转，可以返回 url, 在浏览器执行window.location(url)

### 50. 工具类判断是否是 ajax 请求【request.getHeader("X-Requested-With")】

```java
package com.alq.fruns.utils;

public class WebUtils {

    public static boolean isAjaxRequest(HttpServletRequest request){
        return "XMLHttpRequest".equals(request.getHeader("X-Requested-With"));
    }
}
```

修改 AuthFilter 判断是否是 ajax 请求：

```java
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    //  得到请求的 url ---> 向下转型
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    String url = request.getServletPath();
    Member member = (Member) request.getSession().getAttribute("member");   //  普通员工
    Admin admin = (Admin) request.getSession().getAttribute("admin");   //  普通员工
    if (admin != null){ //  管理员直接放行！！！
        filterChain.doFilter(servletRequest, servletResponse);
        return;
    }

    //  判断是否要验证
    if (!excludedUrlsList.contains(url)){    //  不在排除规则里面 ---> 确认要杀死的！！！
        if(member == null){
            if (!WebUtils.isAjaxRequest(request)) { //  不是 ajax 请求，还按照以前流程走
                request.getRequestDispatcher("/views/member/login.jsp").forward(servletRequest, servletResponse);
            }else { //  是 ajax 请求
                //  采用 数据 ---> MAp ---> Json
                Map<String, Object> resultMap = new HashMap<>();
                resultMap.put("url", "views/member/login.jsp");
                String resultJson = new Gson().toJson(resultMap);	//	map ---> Json
                servletResponse.getWriter().write(resultJson);
            }
            return;
        }
    }

    //  放行 或者 进入下一个过滤器
    filterChain.doFilter(servletRequest, servletResponse);
}

```

### 51. 如果表单是 enctype="multipart/form-data" 格式【无法 req.getparameter()】

![image-20230303163103935](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303031631122.png)

现在发现 Tomcat 吧错误隐藏了，我们想要知道错误发生在哪里，采用的方式：

解决方法：暂时将 500 错误页面给屏蔽掉！！！

![image-20230303163502667](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303031635926.png)

有空指针异常：

![image-20230303164007563](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303031640751.png)

![image-20230303164133802](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303031641084.png)

解决方式：通过 <font color="yellow">**action 的 url**</font> 将参数传过去就行了！！！

```html
<form action="manage/furnServlet?id=${requestScope.furn.id}&action=update&pageNo=${param.pageNo}" method="post" enctype="multipart/form-data">
```

servletFileUpload 需要引入2个  jar 包：

- commons-fileupload-1.2.1.jar
- commons-io-1.4.jar



### 52. 增加业务逻辑使得 普通会员无法访问后台

在 AuthFilter 中增加业务逻辑抑制如下等链接

```bash
http://localhost:8080/jiaju_mall/manage/furnServlet?action=page
```

```java
String regStr = "^(http://localhost:8080/jiaju_mall/manage/)[\\w=?]+$";
```

```java
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    //  得到请求的 url ---> 向下转型
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    String url = request.getServletPath();
    System.out.println("url=" + url);
    Member member = (Member) request.getSession().getAttribute("member");   //  普通员工
    Admin admin = (Admin) request.getSession().getAttribute("admin");   //  普通员工
    if (admin != null){ //  管理员直接放行！！！
        filterChain.doFilter(servletRequest, servletResponse);
        return;
    }

    //  判断是否要验证
    if (!excludedUrlsList.contains(url)){    //  不在排除规则里面 ---> 确认要杀死的！！！
        if(member == null){
            if (!WebUtils.isAjaxRequest(request)) { //  不是 ajax 请求，还按照以前流程走
                request.getRequestDispatcher("/views/member/login.jsp").forward(servletRequest, servletResponse);
            }else { //  是 ajax 请求
                //  采用 数据 ---> MAp ---> Json
                Map<String, Object> resultMap = new HashMap<>();
                resultMap.put("url", "views/member/login.jsp");
                String resultJson = new Gson().toJson(resultMap);	//	map ---> Json
                servletResponse.getWriter().write(resultJson);
            }
            return;
        }else {
            String regStr = "^(http://localhost:8080/jiaju_mall/manage/)[\\w=?]+$";
            String url1 = request.getRequestURL()+"";
            if (url1.matches(regStr)){
                //  登录了但是不是管理员，就不能访问管理员相关目录，跳转到首页！！！
                System.out.println("你不是管理员无法进行操作！！！");
                request.getRequestDispatcher("/index.jsp").forward(servletRequest, servletResponse);
                return;
            }
        }
    }

    //  放行 或者 进入下一个过滤器
    filterChain.doFilter(servletRequest, servletResponse);
}
```

### 53. input type="file" 标签

HTML中使用input type="file"时，不允许修改value属性值

- 在HTML中使用\<inupt type="file">上传文件时，出于安全起见属性value是只读的，不允许在输入框中编辑或修改，
- 在js中用 “xxx.value=” 修改也不行，只能通过“浏览”按钮选择一个文件的方式修改value的值。另外，就算是在定义\<input type="file"时为value属性设置了默认的文件路径，也无法在接收程序中通过Request.getParameter()方法获取，方法返回值为空。这一点与其他input属性的不同之处，使用时尤其要注意。
- 在定义\<input type="file">一定要定义name属性，否则无法获取到上传文件路径，因为在接收程序的getParameter()需要<font color="yellow">**使用name属性**</font> 才可以接收到文件。

### 54. 图片冗余问题【删除上次图片】

![tupian-JavaWeb(1)](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303041808148.jpg)

1. 家居图片都放在一个文件夹，会越来越多，请尝试在assets/images/product-image/目录下自动创建年月日目录比如21001011 ,以天为单位来存放上传图片
2. 当上传新家居图片，原来的图片就没有用了，应当删除原来的家居图片.

```java
public class WebUtils {
    public static String getYearMonthDay(){
        // 3代日期类
        LocalDateTime now = LocalDateTime.now();
        int year = now.getYear();
        int monthValue = now.getMonthValue();
        int dayOfMonth = now.getDayOfMonth();
        String yearMonthDay = year + "/" + monthValue + "/" + dayOfMonth;
        return yearMonthDay;
    }
}
```

![image-20230304182615087](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303041826568.png)

```java
package com.alq.fruns.web;

public class FurnServlet extends BasicServlet {

    private FurnService furnService = new FurnServiceImpl();

    private String toBeDeletedImgPath = "";	//	待删除图片路径！！

    protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        int id = DataUtils.parseInt(req.getParameter("id"), -1);
        Furn furn = furnService.queryFurnById(id);
        System.out.println(furn);
        //  todo 做一个判断：如果 furn 为 null，就不处理了


        System.out.println("FIleUpLoad 被调用！！！");
        //  1. 判断是不是文件表单（enctype="multipart/form-data）
        if (ServletFileUpload.isMultipartContent(req)){
            System.out.println("OK");
            //  2. 创建 DiskFileItemFactory 对象，用于构建一个解析上传数据的工具对象
            DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); // 和 form 有对应关系
            //  3. 构建一个解析上传数据的工具对象
            ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory);

            //  4. 关键地方：servletFileUpload 对象，可以把表单 提交的数据 text / 文件
            //  将其封装到 FileItem 文件项中
            try {
                List<FileItem> list = servletFileUpload.parseRequest(req);
                System.out.println("list = " + list);
                //  遍历，并分别处理
                for (FileItem fileItem : list) {
                    System.out.println("fileItem= " + fileItem);
                    //  判断是不是一个文件 OOP 程序员
                    if (fileItem.isFormField()){    //  true：就是文本 input text
                        if ("name".equals(fileItem.getFieldName())){
                            furn.setName(fileItem.getString("utf-8"));
                        }else if ("maker".equals(fileItem.getFieldName())){
                            furn.setMaker(fileItem.getString("utf-8"));
                        }else if ("price".equals(fileItem.getFieldName())){
                            furn.setPrice(new BigDecimal(fileItem.getString()));
                        }else if ("sales".equals(fileItem.getFieldName())){
                            furn.setSales(Integer.valueOf(fileItem.getString()));
                        }else if ("stock".equals(fileItem.getFieldName())){
                            furn.setStock(Integer.valueOf(fileItem.getString()));
                        }
                    }else { //  是一个文件
                        //  获取上传的名字
                        String name = fileItem.getName();
                        System.out.println("上传的文件名" +  name);
                        if (!"".equals(name)) {
                            //  将这个上传到 服务器的 temp 下的文件保存到你指定的目录
                            //  很多细节
                            //  1. 指定一个目录，就是我们网站的工作目录下
                            String filePath = "/" + WebUtils.FURN_IMG_DIRECTORY;

                            //  2. 获取到完整目录 【io/servlet 基础】
                            String fileRealPath = req.getServletContext().getRealPath(filePath) + "/" + WebUtils.getYearMonthDay();

                            //  3. 创建这个上传的目录
                            File fileRealPathDirectory = new File(fileRealPath);
                            System.out.println(fileRealPathDirectory);
                            if (!fileRealPathDirectory.exists()) {   //  不存在，就创建
                                fileRealPathDirectory.mkdirs();
                            }
                            //  4. 将文件拷贝到  fileRealPathDirectory 目录
                            //  构建一个上传文件的完整路径：目录 + 文件名
                            //  对上传的文件名进行处理，前面增加一个前缀，保证唯一性
                            name = UUID.randomUUID().toString() + "_" + System.currentTimeMillis() + "_" + name;
                            String fullPath = fileRealPathDirectory + "/" + name;
                            System.out.println(fullPath);
                            fileItem.write(new File(fullPath)); //  保存
                            fileItem.getOutputStream().close(); //  关闭流

                            //  更新家居的图片路径
                            String imgPath = furn.getImgPath();
                            toBeDeletedImgPath = req.getServletContext().getRealPath(imgPath);
                            System.out.println("待删除文件路径：" + imgPath);

                            furn.setImgPath(WebUtils.FURN_IMG_DIRECTORY + "/" + WebUtils.getYearMonthDay() + "/" + name);
                        }
                    }
                }

            } catch (Exception e) {
                e.printStackTrace();
            }

        }else {
            System.out.println("不是文件表单！！！");
        }

        //  更新 furn 对象 ---> DB
        furnService.updateFurn(furn);

        //  删除旧照片
        if (!"".equals(toBeDeletedImgPath)){
            System.out.println("==============" + toBeDeletedImgPath);
            File file = new File(toBeDeletedImgPath);
            if (file.exists()) {
                if (file.delete()){
                    System.out.println(toBeDeletedImgPath + "删除成功");
                }else {
                    System.out.println("删除失败");
                }
            }else {
                System.out.println("该文件不存在...");
            }
        }

        //  请求转发到更新成功的页面
        System.out.println("更新成功！！！");
        req.getRequestDispatcher("/views/manage/update_ok.jsp").forward(req, resp);

    }
}
```

### 55. 分页导航完善

![fenye-JavaWeb(1)](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303041936939.jpg)

1. 如果总页数<=5, 就全部显示
2. 如果总页数>5, 按照如下规则显示(这个规则是程序员/业务来确定):
   - 如果当前页是前3 页, 就显示 1-5
   - 如果当前页是后3 页, 就显示最后 5 页
   - 如果当前页是中间页, 就显示当前页 前 2 页, 当前页, 当前页后两页

思路修改 FurnServiceImpl 中的 page 方法！！！

```java
@Override
public Page<Furn> page(int pageNo, int pageSize) {
    //  先创建一个 Page 对象，然后根据实际情况填充属性
    int totalRow = furnDAO.getTotalRow();   //  行数、
    Page<Furn> page = new Page<>();
    page.setPageNo(pageNo);
    page.setPageSize(pageSize);
    page.setPageTotalRow(totalRow);
    //  pageTotalCount 通过计算得到 ---> 一个小小的算法实现
    int pageTotalCount = totalRow / pageSize;   //  页数
    if (totalRow % pageSize > 0){
        pageTotalCount += 1;
    }
    page.setPageTotalCount(pageTotalCount);

    int begin = (pageNo - 1) * pageSize;
    List<Furn> pageItems = furnDAO.getPageItems(begin, pageSize);
    page.setItems(pageItems);
    //  还差一个 url，分页导航，先放一放
    return page;
}
```

涉及到的前端代码：

#### if 嵌套

首页【index.jsp】

```html
<div class="pro-pagination-style text-center mb-md-30px mb-lm-30px mt-6" data-aos="fade-up">
    <ul>
        <%--如果当前页 > 1，就显示上一页（跳转）--%>
        <c:if test="${requestScope.page.pageTotalCount <= 5}">
            <c:if test="${requestScope.page.pageNo > 1}">
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
            </c:if>

            <c:set var="begin" value="1"/>	<!-- 设置起始，为后续限制显示个数做准备！！！ -->
            <c:set var="end" value="${requestScope.page.pageTotalCount}"/>
            <c:forEach begin="${begin}" step="1" end="${end}" var="i">
                <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                <c:if test="${i == requestScope.page.pageNo}">
                    <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                </c:if>
                <c:if test="${i != requestScope.page.pageNo}">
                    <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                </c:if>
            </c:forEach>

            <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
            </c:if>
        </c:if>

        <%-- 总页数 > 5--%>
        <c:if test="${requestScope.page.pageTotalCount > 5}">
            <%-- 前 3 页--%>
            <c:if test="${requestScope.page.pageNo <= 3}">
                <c:if test="${requestScope.page.pageNo > 1}">
                    <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
                </c:if>
                <c:set var="begin" value="1"/>	<!-- 设置起始，为后续限制显示个数做准备！！！ -->
                <c:set var="end" value="5"/>
                <c:forEach begin="${begin}" step="1" end="${end}" var="i">
                    <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                    <c:if test="${i == requestScope.page.pageNo}">
                        <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                    <c:if test="${i != requestScope.page.pageNo}">
                        <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                </c:forEach>
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
            </c:if>
            <%-- 后 3 页--%>
            <c:if test="${requestScope.page.pageNo >= requestScope.page.pageTotalCount - 2}">
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
                <c:set var="begin" value="${requestScope.page.pageTotalCount - 4}"/>	<!-- 设置起始，为后续限制显示个数做准备！！！ -->
                <c:set var="end" value="${requestScope.page.pageTotalCount}"/>
                <c:forEach begin="${begin}" step="1" end="${end}" var="i">
                    <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                    <c:if test="${i == requestScope.page.pageNo}">
                        <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                    <c:if test="${i != requestScope.page.pageNo}">
                        <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                </c:forEach>
                <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
                    <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
                </c:if>
            </c:if>
            <%-- 普通页--%>
            <c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount - 2 && requestScope.page.pageNo > 3}">
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
                <c:set var="begin" value="${requestScope.page.pageNo - 2}"/>	<!-- 设置起始，为后续限制显示个数做准备！！！ -->
                <c:set var="end" value="${requestScope.page.pageNo + 2}"/>
                <c:forEach begin="${begin}" step="1" end="${end}" var="i">
                    <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                    <c:if test="${i == requestScope.page.pageNo}">
                        <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                    <c:if test="${i != requestScope.page.pageNo}">
                        <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                    </c:if>
                </c:forEach>
                <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
            </c:if>
        </c:if>
        <li><a>共${requestScope.page.pageTotalCount}页</a></li>
    </ul>
</div>
```

管理员管理家居【furn_manage.jsp】

#### choose ---> when 嵌套

choose

- when：<= 5 时，全部显示
- when: > 5 时，分为3种情况：还是嵌套
  - choose:
    - when：当前页是前 3页
    - when：当前页是后 3 页
    - otherwise：普通页

这里复用一下 url 代码：

```java
protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    System.out.println("page 被调用");
    int pageNo = DataUtils.parseInt(req.getParameter("pageNo"), 1);
    int pageSize = DataUtils.parseInt(req.getParameter("pageSize"), Page.PAGE_SIZE);
    Page<Furn> page = furnService.page(pageNo, pageSize);
    page.setUrl("manage/furnServlet?action=page");	//	复用 url
    req.setAttribute("page", page);
    req.getRequestDispatcher("/views/manage/furn_manage.jsp").forward(req, resp);
}
```

```html
<div class="pro-pagination-style text-center mb-md-30px mb-lm-30px mt-6" data-aos="fade-up">
    <ul>
    <%--总页数 <= 5 时，全都显示--%>
        <c:choose>
            <c:when test="${requestScope.page.pageTotalCount <= 5}">
                <c:if test="${requestScope.page.pageNo > 1}">   <%--如果当前页 > 1，就显示上一页（跳转）--%>
                    <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a></li>
                        </c:if>

<c:set var="begin" value="1"/> <!-- 设置起始，为后续限制显示个数做准备！！！ -->
    <c:set var="end" value="${requestScope.page.pageTotalCount}"/>
        <c:forEach begin="${begin}" step="1" end="${end}" var="i">
            <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                <c:if test="${i == requestScope.page.pageNo}">
                    <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
                        </c:if>
<c:if test="${i != requestScope.page.pageNo}">
    <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
        </c:if>
</c:forEach>

<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
    <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a></li>
        </c:if>
</c:when>
<%--总页数 > 5 --%>
        <c:when test="${requestScope.page.pageTotalCount > 5}">
            <c:choose>
                <%-- 当前页是前 3 页 --%>
                    <c:when test="${requestScope.page.pageNo <= 3}">
                        <c:if test="${requestScope.page.pageNo > 1}">
                            <li>
                            <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a>
</li>
</c:if>
<c:set var="begin" value="1"/> <!-- 设置起始，为后续限制显示个数做准备！！！ -->
    <c:set var="end" value="5"/>
        <c:forEach begin="${begin}" step="1" end="${end}" var="i">
            <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                <c:if test="${i == requestScope.page.pageNo}">
                    <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a>
</li>
</c:if>
<c:if test="${i != requestScope.page.pageNo}">
    <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
        </c:if>
</c:forEach>
<li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a>
</li>
</c:when>
<%--当前页是后 3页--%>
    <c:when test="${requestScope.page.pageNo >= requestScope.page.pageTotalCount - 2}">
        <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a>
</li>
<c:set var="begin"
value="${requestScope.page.pageTotalCount - 4}"/> <!-- 设置起始，为后续限制显示个数做准备！！！ -->
    <c:set var="end" value="${requestScope.page.pageTotalCount}"/>
        <c:forEach begin="${begin}" step="1" end="${end}" var="i">
            <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                <c:if test="${i == requestScope.page.pageNo}">
                    <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a>
</li>
</c:if>
<c:if test="${i != requestScope.page.pageNo}">
    <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
        </c:if>
</c:forEach>
<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
    <li>
    <a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a>
</li>
</c:if>
</c:when>
<%--普通页--%>
        <c:otherwise>
            <li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo - 1}">上一页</a>
</li>
<c:set var="begin"
value="${requestScope.page.pageNo - 2}"/> <!-- 设置起始，为后续限制显示个数做准备！！！ -->
    <c:set var="end" value="${requestScope.page.pageNo + 2}"/>
        <c:forEach begin="${begin}" step="1" end="${end}" var="i">
            <%--如果 i 是当前页，就是用带 class = active 的 a，来高亮显示--%>
                <c:if test="${i == requestScope.page.pageNo}">
                    <li><a class="active" href="${requestScope.page.url}&pageNo=${i}">第${i}页</a>
</li>
</c:if>
<c:if test="${i != requestScope.page.pageNo}">
    <li><a href="${requestScope.page.url}&pageNo=${i}">第${i}页</a></li>
        </c:if>
</c:forEach>
<li><a href="${requestScope.page.url}&pageNo=${requestScope.page.pageNo + 1}">下一页</a>
</li>
</c:otherwise>
</c:choose>
</c:when>
</c:choose>
<li><a>共${requestScope.page.pageTotalCount}页</a></li>
    </ul>
</div>
```

### 56. promoise_utils  工具

```js
let get = function (url, data) {
    return new Promise((resolve, reject) => {   //  return 给下一个调用者【实际上是一个调用链】
        $.ajax({
            url: url,   //  模板字符串
            data: data,
            error(err) {    //  失败后的回调函数 ---> ES6 简写版
                reject(err);    //  如果出现了 err，就去调用 reject 函数
            },
            success(resultData) {
                //  继续下一次的请求
                resolve(resultData);
            }
        })
    })
}
```

应用：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>课后作业 promise 实现</title>
    <!-- 引入 jQuery-->
    <script type="text/javascript" src="script/jquery-3.6.0.min.js"></script>
    <script type="text/javascript" src="script/promise_utils.js"></script>  <!-- 引入 promise的工具方法 get-->
    <script type="text/javascript">
        //  1. get：请求
        //  2. then：拿到
        get("data/student_100.json")
            .then((resultData) =>{
                console.log("第1 次 ajx 请求返回的数据=", resultData);
                return get(`data/class_${resultData.class_id}.json`)    //  return：链式调用！！！
            }).then((resultData) =>{
            console.log("第2 次 ajx 请求返回的数据=", resultData);
            return  get(`data/school_${resultData.school_id}.json`)
        }).then((resultData) => {
            console.log("第3 次 ajx 请求返回的数据=", resultData);
        }).catch((err) => { //  ES6 箭头函数如果只有一个参数，可以不用小括号
            console.log("promise 异步请求异常=", err);
        })

    </script>
</head>
<body>

</body>
</html>
```

### 57. VUE 引入

el：element 的简写！！！

- id选择器：#
- class 选择器 .

v-on:click 表示我们要给 button 元素绑定一个 click 事件

sayHi() 表示绑定的方法，在方法池 methods{}  中定义的

data：数据域

methods：方法域

```html
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>事件处理</title>
</head>
<body>
<div id="app">
    <h1>{{message}}</h1>
    <button v-on:click="sayHi()">点击输出</button>
    <button v-on:click="sayOk()">点击输出</button>
</div>
<script src="vue.js"></script>
<script>
    let vm = new Vue({
        el: "#app", //创建的vue实例挂载到 id=app的div
        data: { //data{} 表示数据池(model的有了数据), 有很多数据 ,以k-v形式设置(根据业务需要来设置)
            message: "VUE 事件处理案例",
            //  1. 是一个 methods 属性，对应的值是对象 {}
            //  2. 在 {} 中可以写很多方法，可以这样理解，是一个方法池
        },
        methods: {
            sayHi() {
                console.log("hi, 银角大王~");
            },
            sayOk() {
                console.log("ok, 金角大王！")
            }
        }
    });
    console.log("vm=>", vm);
</script>
</body>
</html>
```

### 58. 全局组件

```html
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>全局组件</title>
</head>
<body>

<div id="app">
    <h1>组件化编程，全局组件</h1>
    <!--使用全局组件-->
    <counter></counter><br>
    <counter></counter>
</div>
<script src="vue.js"></script>
<script>
    //  1. 定义一个全局组件，名称为 counter
    //  2. {} 就是我们组件相关的内容
    //  3. template 指定该组件的界面，因为会引用到数据池的数据，所以需要使用模板字符串
    //  4. 说明：要把组件视为一个 VUE 实例，也有自己的数据池和 methods
    //  5. 说明：对于组件，我们的数据池的数据，是使用函数 / 方法返回【保证每个组件的数据独立】，不能使用原来的方式了
    //  6. 这时，我们达到目的，界面通过 template 实现共享，业务处理也复用

    Vue.component("counter",{
        template: `<button v-on:click="click()">点击次数=非组件化方式 {{count}}</button><br>`,
        data(){
            return{
                count: 10
            }
        },
        methods: {
            click(){
                this.count += 1;
            }
        }
    })

    //  创建 Vue 实例，必须有
    new Vue({
        el: "#app",
    })
</script>

</body>
</html>
```

### 59. 局部组件

```html
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>局部组件</title>
</head>
<body>

<div id="app">
    <h1>组件化编程，局部组件</h1>
    <!--使用局部组件，该组件是从挂载到 app 的vue中的-->
    <my_counter></my_counter><br>
    <my_counter></my_counter><br>
    <my_counter></my_counter><br>
</div>
<script src="vue.js"></script>
<script>
    //  定义一个组件 【本质就是一个对象】
    //  扩展
    //  1. 可以把常用的组件，定义在某个 common.js 中 export
    //  2. 如果某个页面需要使用，直接 import 即可
    const buttonCounter = {
        template: `<button v-on:click="click()">点击次数=局部组件化方式 {{count}}</button><br>`,
        data(){
            return{
                count: 10
            }
        },
        methods: {
            click(){
                this.count += 1;
            }
        }
    }

    //  创建 Vue 实例，必须有
    new Vue({
        el: "#app",
        components: {   //  引入某个组件，此时 my_counter 就是一个组件，是一个局部组件，它的使用范围：当前 vue
            'my_counter': buttonCounter
        }
    })
</script>

</body>
</html>
```

### 60. HelloWorld.vue 原始代码

```html
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    <h2>Essential Links</h2>
    <ul>
      <li>
        <a
          href="https://vuejs.org"
          target="_blank"
        >
          Core Docs
        </a>
      </li>
      <li>
        <a
          href="https://forum.vuejs.org"
          target="_blank"
        >
          Forum
        </a>
      </li>
      <li>
        <a
          href="https://chat.vuejs.org"
          target="_blank"
        >
          Community Chat
        </a>
      </li>
      <li>
        <a
          href="https://twitter.com/vuejs"
          target="_blank"
        >
          Twitter
        </a>
      </li>
      <br>
      <li>
        <a
          href="http://vuejs-templates.github.io/webpack/"
          target="_blank"
        >
          Docs for This Template
        </a>
      </li>
    </ul>
    <h2>Ecosystem</h2>
    <ul>
      <li>
        <a
          href="http://router.vuejs.org/"
          target="_blank"
        >
          vue-router
        </a>
      </li>
      <li>
        <a
          href="http://vuex.vuejs.org/"
          target="_blank"
        >
          vuex
        </a>
      </li>
      <li>
        <a
          href="http://vue-loader.vuejs.org/"
          target="_blank"
        >
          vue-loader
        </a>
      </li>
      <li>
        <a
          href="https://github.com/vuejs/awesome-vue"
          target="_blank"
        >
          awesome-vue
        </a>
      </li>
    </ul>
  </div>
</template>

<script>
export default {  //  组件【可以看作 vue 实例】
  name: 'HelloWorld',
  data () { //  数据池
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
</style>

```

### 61. Vue 非简写版本

注意：导入名字由自己确定

```java
//对应导入方式, 导入名字自己指定,通过.方式来选择调用函数/变量
import m from "./es6_common"
```

```js
//	完整写法
import Vue from 'vue'	//	类似与 java 使用 hashMap 就要先引入
import App from './App.vue'	
import router from './router/index.js'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',	//这里的#app 是挂到index.html 的<div id="app"></div>
  router,	//完整写法是 router: router, 第二个router 是import router[这里] from './router'
  components: { App }, //完整写法是components: { 'App':App } 因为名字相同可以省略'App'
  template: '<App></App>' 
})
```

### 62. Vue 请求页面执行流程

![image-20230315183928012](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303151839363.png)

### 63. table 不居中的原因

![image-20230315201331884](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303152013014.png)

因为最终的页面会到 App.vue 中

这个页面中有：

```vue
<style>
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;	# 
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```

现在你在 alq.vue 中写了这个样式

```html
<!-- 因为它的优先级高，所以后面的居中样式，就不会生效了-->
<style scoped>
div {
  width: 900px;
  background-color: aliceblue;
}
</style>
```

解决方式：增加一条前端样式

```html
<!--样式 css，可以修饰页面视图-->
<!--
	0：上下边距
	auto：左右居中
-->
<style scoped>
div {
  width: 900px;
  background-color: aliceblue;
  margin: 0 auto;
}
</style>
```

### 64. debugger 设置

![image-20230318162924887](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303181629993.png)

![image-20230318163018371](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303181630485.png)

### 65. Java Volatile关键字【触发刷新】

Java的volatile关键字用于标记一个变量“应当存储在主存”。更确切地说，每次读取volatile变量，都应该从主存读取，而不是从CPU缓存

取。每次写入一个volatile变量，应该写到主存中，而不是仅仅写到 CPU缓存。

<font color="yellow">**变量可见性** </font>问题：

Java的volatile关键字能保证变量修改后，对各个线程是可见的。这个听起来有些抽象，下面就详细说明。

在一个多线程的应用中，线程在操作非volatile变量时，出于性能考虑，每个线程可能会将变量从主存拷贝到 CPU缓存 中。如果你的计算机有多个CPU，每个线程可能会在不同的CPU中运行。这意味着，每个线程都有可能会把变量拷贝到各自CPU的缓存中，如下图所示：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303181906714.png)

对于非volatile变量，JVM并不保证会从主存中读取数据到CPU缓存，或者将CPU缓存中的数据写到主存中。这会引起一些问题，在后面的章节中，我会来解释这些问题。

试想一下，如果有两个以上的线程访问一个共享对象，这个共享对象包含一个counter变量，下面是代码示例：

```java
public class SharedObject {
    public int counter = 0;
}
```

如果只有线程1修改了（自增）counter变量，而线程1和线程2两个线程都会在某些时刻读取counter变量。

如果counter变量没有声明成volatile，则counter的值不保证会从CPU缓存写回到主存中。也就是说，CPU缓存和主存中的counter变量值并不一致，如下图所示：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303181929435.png)

这就是“可见性”问题，线程看不到变量最新的值，因为其他线程还没有将变量值从CPU缓存写回到主存。一个线程中的修改对另外的线程是不可见的。

volatile可见性保证

Java的volatile关键字就是设计用来解决变量可见性问题。将counter变量声明为volatile，则在写入counter变量时，也会 <font color="yellow">**同时将变量值写入到主存** </font>中。同样的，在读取counter变量值时，也会直接从主存中读取。

下面的代码演示了如果将counter声明为 volatile：

```java
public class SharedObject {
    public volatile int counter = 0;
}
```

将一个变量声明为volatile，可以保证变量写入时对其他线程的可见。

在上面的场景中，一个线程（T1）修改了counter，另一个线程（T2）读取了counter（但没有修改它），将counter变量声明为volatile，就能保证写入counter变量后，对T2是可见的。

然而，如果 <font color="red"> **T1**和**T2**</font> 都修改了counter的值，只是将counter声明为volatile还远远不够，后面会有更多的说明。

实际上，volatile的可见性保证并不是只对于volatile变量本身那么简单。可见性保证遵循以下规则：

- 如果线程A写入一个volatile变量，线程B随后读取了同样的volatile变量，则线程A在写入volatile变量之前的所有可见的变量值，在线程B读取volatile变量后也同样是可见的。
- 如果线程A读取一个volatile变量，那么线程A中所有可见的变量也会同样从主存重新读取。

代码说明：

```java
 
public class MyClass {
    private int years;
    private int months
    private volatile int days;
 
 
    public void update(int years, int months, int days){
        this.years  = years;
        this.months = months;
        this.days   = days;
    }
}
```

update() 方法写入 3 个变量，其中只有 days 变量是 volatile

- 完整的 volatile 可见性意味着，在写入 days 变量时，线程中所有可见变量也会写入到主存。
- 也就是说：，写入days变量时，years和months也会同时被写入到主存

下面的代码读取了years、months、days变量：

```java
 public class MyClass {
    private int years;
    private int months
    private volatile int days;
 
    public int totalDays() {
        int total = this.days;
        total += months * 30;
        total += years * 365;
        return total;
    }
 
    public void update(int years, int months, int days){
        this.years  = years;
        this.months = months;
        this.days   = days;
    }
}
```

请注意totalDays()方法开始读取days变量值到 total 变量。在读取days变量值时，months和years的值也会同时从主存读取。

因此，按上面所示的顺序读取时，可以保证读取到 days、months、years变量的最新值。

译者注：可以将 <font color="yellow">对volatile**变量的读写**</font> 理解为一个<font color="yellow">触发刷新的操作</font>，写入volatile变量时，线程中的所有变量也都会触发写入主存。而读取volatile变量时，也同样会触发线程中所有变量从主存中重新读取。

- 因此，应当尽量将volatile的写入操作放在最后，
- 而将volatile的读取放在最前，
  - 这样就能连带将其他变量也进行刷新。上面的例子中，update()方法	对days的赋值就是放在years、months之后，就是保证years、months也能将最新的值写入到主存，如果是放在两个变量之前，则days会写入主存，而years、months则不会。
  - 反过来，totalDays()方法则将days的读取放在最前面，就是为了能同时触发刷新years、months变量值，如果是放后面，则years、months就可能还是从CPU缓存中读取值，而不是从主存中获取最新值。

### 66. beans.xml name 爆红

1. beans.xml 中配置的 bean 太多了
2. 窗口开得太多了
3. 清除缓存，再重启

### 67. Spring 懒加载【Spring 默认不是懒加载，而是迫切加载】

1. Spring懒加载 就是延迟创建bean的时间，通常在初始化容器的时候就创建bean，设置了懒加载后，在创建容器的时候不创建bean，在需要用到这个bean的时候才去创建这个bean

2. 懒加载的应用的场景：如果某个bean在系统运行的整个周期都有可能不使用，那么就可以设置为懒加载

3. 懒加载的优点：节省了资源

4. 懒加载的缺点：响应的时间整个周期比较长

5. 与懒加载相对应的就是迫切加载，Spring默认的就是迫切加载，优缺点和懒加载相反

6. 将交给spring管理的类设置为懒加载

   ```xml
   <bean id="animal" class="cn.xjxwc666.spring.Animal" lazy-init="true"></bean>
   ```

 总结：是不是懒加载主要是看创建容器的时候，会不会去创建对象，默认是迫切加载就会创建

### 68. classpath

![image-20230323123531068](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303231235199.png)

### 69.  得到 web.xml 文件路径

```java
//  接收一个容器的配置文件，比如：beans.xml，该文件默认在 src
String path = this.getClass().getResource("/").getPath();
System.out.println("path= " + path);
```

```bash
# 工作目录路径
D:/spring5/out/production/spring5/beeans.xml
```

### 70. 通过类加载器获取要扫描包的真正路径

```java
// 	得到扫描包下的所有资源(类.class) ===> 工作目录的 class
URL resource = configClass.getClassLoader().getResource(path);  //  URL 对象有许多 API
path = resource.getPath();
System.out.println("我们真正要扫描的路径如下：");
System.out.println(path);
```

任何一个 Class 文件的 类加载器都可以

```java
package com.llq.spring.annotation;

/**
 * LlqSpringApplicationContext 作用类似：Spring 原生 IOC 容器
 */
public class LlqSpringApplicationContext {
    private Class configClass;
    //  存放的是通过反射创建的对象（基于注解方式）
    private final ConcurrentHashMap<Object, Object> singleTonObject = new ConcurrentHashMap<>();

    public LlqSpringApplicationContext(Class configClass) {
        //  这里拿到了自定义配置类的 Class 类型
        this.configClass = configClass;
        System.out.println("配置类的 Class 类型");
        System.out.println("this.configClass= " + this.configClass);
        //  1. 先得到 LlqSpringConfig 配置的注解 @ComponentScan(value = "com.llq.spring.component")
        ComponentScan declaredAnnotation = (ComponentScan)this.configClass.getDeclaredAnnotation(ComponentScan.class);
        //  2. 通过 ComponentScan的 value ===> 要扫描的包
        String path = declaredAnnotation.value();
        System.out.println("待扫描的包如下：");
        System.out.println(path);   //  com.llq.spring.component ===> 路径的话，要将 . 替换为 、 ===》com/llq/spring/component
        path = path.replace(".", "/");

        //  3. 得到扫描包下的所有资源(类.class) ===> 工作目录的 class
        URL resource = configClass.getClassLoader().getResource(path);  //  URL 对象有许多 API
        path = resource.getPath();
        System.out.println("我们真正要扫描的路径如下：");
        System.out.println(path);

        //  4. 将要加载的资源(.class) 路径下的文件进行遍历 ===> IO 知识

        File file = new File(path); //  得到目录
        File[] files = file.listFiles();    //  列出目录下的所有文件
        for (File f : files) {
            System.out.println(f.getAbsolutePath());
        }
    }
}
```

### 71. 2种 获得 Class 对象的反射方法的区别

- 传统方式 Class.forName() 会调用该类的静态方法
- 使用类加载器则不会

```java
//	一般方式
Class.forname(classFullName)
    
//	使用类加载器【较为轻量级】
classLoader.loadClass(classFullName)
```

### 72. 判断 Class 对象是否包含某个注解

```java
//	isAnnotationPresent(Service.class)
Class<?> aClass = Class.forName(classFullName);

if (aClass.isAnnotationPresent(Service.class) ||
    aClass.isAnnotationPresent(Controller.class) || aClass.isAnnotationPresent(Component.class) ||
    aClass.isAnnotationPresent(Repository.class)){
    System.out.println("ok");
    Object o = aClass.getConstructor().newInstance();
    System.out.println("获得对象并放入容器中");
    singleTonObjects.put(classFullName, o);
}
```

### 73. StringUtils工具类实现首字母小写

源自 Spring 框架

![image-20230326205314067](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303262053303.png)

```java
StringUtils.uncapitalize(className)
```

![image-20230327101429961](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303271014533.png)

还可以在 Maven pom.xml 中进行引入：	

```xml
<!-- org.apache.commons.lang -->
<dependency>
    <groupId>commons-lang</groupId>
    <artifactId>commons-lang</artifactId>
    <version>2.6</version>
</dependency>
```

### 74. beans.xml 中 注解配置和XML配置并不冲突

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 定义Spring容器创建时，要去扫描的包！！！ -->
    <context:component-scan base-package="com.llq.spring.component"/>

    <!-- XML配置和注解配置并不冲突-->

    <!-- 配置两个 UserService 对象-->
    <bean class="com.llq.spring.component.UserService" id="userService200"/>
    <bean class="com.llq.spring.component.UserService" id="userService300"/>

</beans>
```

此时在容器中，就有 3个 UserService 对象，它们的 id 分别是：

- userService【通过注解，自动扫描的id 默认就是 类名首字母小写！！！】
- userService200
- userService300


### 75. Spring 单例模式的理解【scope=singleton / prototype】

单例：集合手写 主键

```java
//	单利下，所有的 bean 都存放在 Map 中
//	所以每次 getBean 都会返回同一对象
private final ConcurrentHashMap<Object, Object> singleTonObject = new ConcurrentHashMap<>();
```

```java
package com.llq.spring.annotation;

/**
 * LlqSpringApplicationContext 作用类似：Spring 原生 IOC 容器
 */
public class LlqSpringApplicationContext {
    private Class configClass;
    //  存放的是通过反射创建的对象（基于注解方式）
    private final ConcurrentHashMap<Object, Object> singleTonObject = new ConcurrentHashMap<>();

    public LlqSpringApplicationContext(Class configClass) {
        //  这里拿到了自定义配置类的 Class 类型
        this.configClass = configClass;
        System.out.println("配置类的 Class 类型");
        System.out.println("this.configClass= " + this.configClass);
        //  1. 先得到 LlqSpringConfig 配置的注解 @ComponentScan(value = "com.llq.spring.component")
        ComponentScan declaredAnnotation = (ComponentScan)this.configClass.getDeclaredAnnotation(ComponentScan.class);
        //  2. 通过 ComponentScan的 value ===> 要扫描的包
        String path = declaredAnnotation.value();
        System.out.println("待扫描的包如下：");
        System.out.println(path);

    }

    public Class getConfigClass() {
        return configClass;
    }
}
```

当 Spring 容器启动后，单例  Singleton 默认就会创建，并放入到 singletonObjects 集合

而多例模式，它不知道要创建多少个，所以不会默认创建，该 bean 是在 getBean() 时才会创建

### 75. 开启AOP 注解  功能 \<aop:aspectj-autoproxy/> ===> 这样得到的 bean 才是 运行类型是 Proxy 的代理对象【编译类型是接口类型】，否则拿到的就是普通对象，普通对象是切不进去的

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--现在是基于注解来玩的，所以先定义扫描位置-->
    <context:component-scan base-package="com.llq.spring.aop.aspectJ"/>

    <!-- 开启基于注解的 AOP 功能-->
    <aop:aspectj-autoproxy/>
</beans>
```

这样才能让 <font color="yellow">@**Aspect**</font> 注解生效

```java
package com.llq.spring.aop.aspectJ;

/**
 * 切面类
 * 类似我们之前写的 MyProxyProvider，但是功能强大很多
 */
@Aspect //  切面类【底层切面编程的支撑（动态代理 + 反射 + 动态绑定 ...）】
@Component  //  Spring 容器会注入 SmartAnimalAspect
public class SmartAnimalAspect {
    //  希望将 f1() 方法切入到 Animal 的 getSum 前执行 ===> 前置通知


    /**
     * 解读
     * 1. @Before：表示 前置通知【目标对象执行方法前执行】
     * 2. value = "execution(指定 切入到哪个类的 哪个方法)"
     *      形式为：访问修饰符  + 返回类型 + 全类名.方法名(形参列表) ===> 为什么带形参列表？【可能方法名相同，进行了方法重载】
     * 3. f1(JoinPoint joinPoint) 方法可以理解成就是一个切入方法，方法名由程序员指定 【一般为：showBeginLog】
     *
     * @param joinPoint：在底层执行时，由 AspectJ切面编程框架，会给该切入方法传入 JoinPoint 对象
     *                   通过该对象方法，程序员可以得到 相关信息
     */
    @Before(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
    public static void f1(JoinPoint joinPoint){
        //  通过连接点对象 joinPoint 可以拿到方法签名
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        Object[] args = joinPoint.getArgs();    //  同理，拿到参数


        List<Object> objects = Arrays.asList(args);
        System.out.println("方法名-" + name + "-参数" + objects.toString()); //  1. 横切关注点：前置通知
    }

    //  2. 定义一个方法，在目标对象执行后执行
    public static void after(Method method, Object result){
        System.out.println("方法名字-" + method.getName() + " -结果 result= " + result); //  2. 很且关注点：返回通知

    }
}
```

![image-20230331113316886](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303311133161.png)

不开 AOP 注解：

![image-20230331132508701](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303311325883.png)

开启 AOP 注解：

![image-20230331132550072](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202303311325254.png)

### 76. 切入点表达式复用【定义一个方法，添加注解@Pointcut(value="execution(...)"在后面使用时可以直接引用，提高复用性)】

```java
@Pointcut(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
```

注意：如果 目标类和切面类在同一个包下，可以省略包名【只有注解方式下，才可以。如果是 XML 方式，因为 XML文件和目标类文件不再同一包下，所以必须使用全路径！！！】

即：

```java
@Pointcut(value = "execution(public double Animal.getSum(double, double))")
```

```java
package com.llq.spring.aop.aspectJ;

/**
 * 切面类
 */
@Aspect //  切面类【底层切面编程的支撑（动态代理 + 反射 + 动态绑定 ...）】
@Component  //  Spring 容器会注入 SmartAnimalAspect
public class SmartAnimalAspect {
    @Pointcut(value = "execution(public double com.llq.spring.aop.aspectJ.Animal.getSum(double, double))")
    //  定义一个切入点，在后面使用时可以直接引用，提高复用性
    public void myPointCut(){}

    //  1. 前置通知

    //  这里使用定义好的切入点
    @Before(value = "myPointCut()")
    public void f1(JoinPoint joinPoint){
        //  通过连接点对象 joinPoint 可以拿到方法签名
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();
        Object[] args = joinPoint.getArgs();    //  同理，拿到参数

        List<Object> objects = Arrays.asList(args);
        System.out.println("切面类f1() 方法名-" + name + "-执行前日志：-参数" + objects.toString()); //  1. 横切关注点：前置通知
    }

    //  2. 返回通知
    @AfterReturning(value = "myPointCut()", returning = "res")
    public void f2(JoinPoint joinPoint, Object res){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f2() 方法名-" + name + " -方法正常结束执行后日志---> 目标方法返回的结果：" + res);

    }

    //  3. 异常通知
    @AfterThrowing(value = "myPointCut()", throwing = "e1")
    public void f3(JoinPoint joinPoint, Throwable e1){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f3() 方法名-" + name + " -方法出现异常 ---> 异常信息：" + e1);
    }

    //  4. 最终通知：即把方法 f4 切入到目标方法执行后（不管是否发生异常，都要执行，类似 finally{}）
    @After(value = "myPointCut()")
    public void f4(JoinPoint joinPoint){
        Signature signature = joinPoint.getSignature();
        String name = signature.getName();

        System.out.println("切面类f4() 方法名-" + name + " -方法最终执行完毕");
    }
}
```

使用 XML 方式配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 使用 XML 配置，完成AOP 编程-->
    <!-- 1. 配置切面类 Bean-->
    <bean class="com.llq.spring.aop.xml.SmartAnimalAspect" id="smartAnimalAspect"/>

    <!-- 2. 配置目标类 Bean-->
    <bean class="com.llq.spring.aop.xml.Animal" id="animal"/>

    <!-- 3. 配置切面类关系 -->
    <aop:config>
        <!-- 配置切入点表达式 -->
        <aop:pointcut id="myPointCut" expression="execution(public double com.llq.spring.aop.xml.Animal.getSum(double, double))"/>
        <!-- 配置切面的前置，返回，异常，最终通知-->
        <aop:aspect ref="smartAnimalAspect" order="1">
            <!-- 配置前置通知 -->
            <aop:before method="f1" pointcut-ref="myPointCut"/>
            <!-- 配置返回通知-->
            <aop:after-returning method="f2" pointcut-ref="myPointCut" returning="res"/>
            <!-- 配置异常通知-->
            <aop:after-throwing method="f3" pointcut-ref="myPointCut" throwing="e1"/>
            <!-- 配置最终通知-->
            <aop:after method="f4" pointcut-ref="myPointCut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

### 77. Maven 项目中 beans.xml 文件位置

![image-20230403193654767](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202304031936980.png)



```java
package com.llq.spring;

public class AppMain {

    public static void main(String[] args) {
        //  测试看看是否可以得到 Spring 容器中的 bean
        //  同时观察依赖注入，是否正确！！！
        //  1. 如果是普通的 java 项目，beans.xml 放在 src 目录下
        //  2. 如果是 java maven 项目，beans.xml 放在 src/main/resources 下

        ApplicationContext ioc = new ClassPathXmlApplicationContext("beans.xml");
        UserAction userAction1 = ioc.getBean("userAction", UserAction.class);
        UserAction userAction2 = ioc.getBean("userAction", UserAction.class);
        System.out.println(userAction1);
        System.out.println(userAction2);
    }
}
```

### 78. JDK没有JAVAX.ANNOTATION.JAR包解决方案，无法使用@RESOURCE解决方案

普通项目：下载 [javax.annotation-api-1.3.2.jar](https://repo1.maven.org/maven2/javax/annotation/javax.annotation-api/1.3.2/javax.annotation-api-1.3.2.jar)，并在 lib 目录中引入即可

Maven项目：在 pom.xml 中进行配置

```xml
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>jsr250-api</artifactId>
    <version>1.0</version>
</dependency>
```

### 79. 类加载器

Java 类加载器（3种）

| 加载器    | 对应路径                                      |
| --------- | --------------------------------------------- |
| Bootstrap | jre/lib                                       |
| Ext       | jre/lib/ext                                   |
| App       | classpath【就是 java.exe 执行时，指定的路径】 |

```bash
D:\Java\jdk-14.0.1\bin\java.exe "-javaagent:D:\Program Files (x86)\JetBrains\IntelliJ IDEA 2020.1.2\lib\idea_rt.jar=5999:D:\Program Files (x86)\JetBrains\IntelliJ IDEA 2020.1.2\bin" -Dfile.encoding=UTF-8 -
# 看下 classpath
classpath D:\llq-spring\target\classes;C:\Users\李隆齐\.m2\repository\org\springframework\spring-context\5.3.8\spring-context-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-aop\5.3.8\spring-aop-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-beans\5.3.8\spring-beans-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-core\5.3.8\spring-core-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-jcl\5.3.8\spring-jcl-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-expression\5.3.8\spring-expression-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\springframework\spring-aspects\5.3.8\spring-aspects-5.3.8.jar;C:\Users\李隆齐\.m2\repository\org\aspectj\aspectjweaver\1.9.6\aspectjweaver-1.9.6.jar;C:\Users\李隆齐\.m2\repository\javax\annotation\jsr250-api\1.0\jsr250-api-1.0.jar com.llq.spring.AppMain
```

可以看到 classpath中包含：<font color="yellow">target/**classes**</font> 路径 ===> 所以才能加载你自定义的类

### 79. 扫描路径scanDir 与 反射Path

1. 通过获取配置类 @Component 注解的 value ===> com.llq.spring.component【<font color="red">**Path**</font>】

   ```bash
   # 初始 Path ===> 源自配置类的 @Component注解的 value
   com.llq.spring.component
   # 反射中的 classFullPath
   String classFullPath = com.llq.spring.component + 类名
   ```

2. 定义一个变量 String 【<font color="blue">**scanDir**</font>】 用来存储扫描路径

   ```bash
   # 初始 scanDir ===> com/llq/spring/component ===> 符合 IO 格式，用于查找目录下所有的 .class 文件
   String scanDir = path.replace(".", "/"); com/llq/spring/component
   # 得到扫描包下的所有资源(类.class) ===> 工作目录的 class
   URL resource = configClass.getClassLoader().getResource(scanDir);  //  URL 对象有许多 API
   scanDir = resource.getPath(); /D:/llq-myspring/target/classes/com/llq/spring/component
   ```

3. 查找文件夹下的所有的 .class 文件

   ```java
   File file = new File(scanDir); //  得到目录
   File[] files = file.listFiles();    //  列出目录下的所有文件
   for (File f : files) {
       String absolutePath = f.getAbsolutePath();
       //  注意这里，只处理 .class 文件
       if (absolutePath.endsWith(".class")) {
   
           System.out.println(absolutePath);   //  D:\spring5\out\production\spring5\com\llq\spring\component\UserService.class
           //  现在反射需要得到：com.llq.spring.component.UserService
           //  1. 先获取类名
           String[] split = absolutePath.split("\\\\");
           String className = split[split.length - 1].split("\\.")[0];
           //  得到类名
           System.out.println("类名：" + className);
           //	得到反射路径
           String classFullName = path + "." + className; // 包名 + 类名
           System.out.println(classFullName);
           try {
               Class<?> aClass = Class.forName(classFullName);
               if (aClass.isAnnotationPresent(Component.class)) {
                   //  如果该类使用了 @Component 注解，说明是 Spring Bean
                   System.out.println("这是一个 Spring Bean= " + aClass);
               }else {
                   System.out.println("这不是一个 Spring Bean");
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

```java
package com.llq.spring.ioc;

/**
 * Spring 原生 Ioc 容器
 */
public class LlqSpringApplicationContext {
    private Class configClass;
    //  存放的是通过反射创建的对象（基于注解方式）
    private final ConcurrentHashMap<Object, Object> singleTonObject = new ConcurrentHashMap<>();

    public LlqSpringApplicationContext(Class configClass) {
        //  这里拿到了自定义配置类的 Class 类型
        this.configClass = configClass;
        System.out.println("配置类的 Class 类型");
        System.out.println("this.configClass= " + this.configClass);
        //  1. 先得到 LlqSpringConfig 配置的注解 @ComponentScan(value = "com.llq.spring.component")
        ComponentScan declaredAnnotation = (ComponentScan) this.configClass.getDeclaredAnnotation(ComponentScan.class);
        //  2. 通过 ComponentScan的 value ===> 要扫描的包
        String path = declaredAnnotation.value();
        System.out.println("待扫描的包如下：");
        System.out.println(path);   //  com.llq.spring.component ===> 路径的话，要将 . 替换为 、 ===》com/llq/spring/component
        String scanDir = path.replace(".", "/");
        System.out.println(path);

        //  3. 得到扫描包下的所有资源(类.class) ===> 工作目录的 class
        URL resource = configClass.getClassLoader().getResource(scanDir);  //  URL 对象有许多 API
        scanDir = resource.getPath();
        System.out.println("我们真正要扫描的路径如下：");
        System.out.println(scanDir);

        //  4. 将要加载的资源(.class) 路径下的文件进行遍历 ===> IO 知识

        File file = new File(scanDir); //  得到目录
        File[] files = file.listFiles();    //  列出目录下的所有文件
        for (File f : files) {
            String absolutePath = f.getAbsolutePath();
            //  注意这里，只处理 .class 文件
            if (absolutePath.endsWith(".class")) {

                System.out.println(absolutePath);   //  D:\spring5\out\production\spring5\com\llq\spring\component\UserService
                //  现在反射需要得到：com.llq.spring.component.UserService
                //  1. 先获取类名
                String[] split = absolutePath.split("\\\\");
                String className = split[split.length - 1].split("\\.")[0];
                //  得到类名
                System.out.println("类名：" + className);
                //  再将 / 改回成 .
                String classFullName = path + "." + className; // 包名 + 类名
                System.out.println(classFullName);

                //  2. 判断该类是否需要注入到容器中
                //      观察该类是否包含以下注解
                //      @Component、@Service、@Repository、@Controller
                try {
                    Class<?> aClass = Class.forName(classFullName);
                    if (aClass.isAnnotationPresent(Component.class)) {
                        //  如果该类使用了 @Component 注解，说明是 Spring Bean
                        System.out.println("这是一个 Spring Bean= " + aClass);
                    }else {
                        System.out.println("这不是一个 Spring Bean");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
    //  编写方法，返回容器中对象
    public Object getBean(String name){
        return null;
    }
}
```

### 80. 判断 Class 对象是否实现了某个接口

- Class 文件不能用 instanceof 来判断是否实现了 BeanProcessor 接口
- 因为 Class 文件不是一个实例对象，而是一个类对象，使用 isAssignableFrom

```java
if (BeanPostProcessor.class.isAssignableFrom(aClass)){
    ArrayList.add((BeanPostProcessor) aClass.getConstructor().newInstance());
}
```

### 81. 在 main 方法中调用系统类加载器，并扫描文件夹

```bash
jk	# 文件夹
├─ ACCC.java
├─ EEE.java
├─ Koko.java
├─ NNQ.java
├─ Scan.java
└─ VQQ.java
```

```java
package com.llq.jk;

public class Scan {
    public static void main(String[] args) {
        String scanDir = "com/llq/jk";
        //  系统类加载器 ---> getResource() 方法
        URL resource = ClassLoader.getSystemClassLoader().getResource(scanDir);
        String path = resource.getPath();
        File fileDir = new File(path); //  指向目录
        File[] files = fileDir.listFiles();
        for (File file : files) {
            System.out.println(file);   //  getPath()
        }
    }
}
```

### 82. 获取切面类方法的注解

```java
public class Test {
        public static void main(String[] args) throws NoSuchMethodException,
    InvocationTargetException, IllegalAccessException, InstantiationException {
        Class<SmartAnimalAspect> smartAnimalAspectClass = SmartAnimalAspect.class;
        for (Method declaredMethod : smartAnimalAspectClass.getDeclaredMethods()) {
            if (declaredMethod.isAnnotationPresent(Before.class)) {
                System.out.println("m:= " + declaredMethod.getName());
                Before annotation = declaredMethod.getAnnotation(Before.class);
                System.out.println("value:= " + annotation.value());
                //得到切入要执行的方法.
                Method declaredMethod1 =
                    smartAnimalAspectClass.getDeclaredMethod(declaredMethod.getName());
                //调用切入方法
                declaredMethod1.invoke(smartAnimalAspectClass.newInstance(),null);	//	Before ---> 方法
            } else if(declaredMethod.isAnnotationPresent(After.class)) {
                System.out.println("m:= " + declaredMethod.getName());
                After annotation = declaredMethod.getAnnotation(After.class);
                System.out.println("value:= " + annotation.value());
                //得到切入要执行的方法.
                    Method declaredMethod1 =
                    smartAnimalAspectClass.getDeclaredMethod(declaredMethod.getName());
                //调用切入方法
                declaredMethod1.invoke(smartAnimalAspectClass.newInstance(),null);	//	After ---> 方法
            }
        }
    }
}
```

如果向进一步实现的话：

1. 通过注解【切入点表达式】看看当前这个类是否已经被代理【需要事先就在Map 中代理保存关系】
2. 通过注解【切入点表达式】看看当前这个类的哪个方法已经被代理【需要事先就在Map 中代理保存关系】
3. 通过注解@Before 看看当前这个类的这个方法已经被切面类的哪个方法进行@Before 切入【需要事先
   就在Map 中代理保存关系】
4. 通过注解@AfterReturing 看看当前这个类的这个方法已经被切面类的哪个方法进行@AfterReturing 切入【需要事先就在Map 中代理保存关系】

### 83. 数组对象初始化

引用类型数组初始化

```java
Object[] objects = new Object[]{600, "张飞", "蛮牛式"};
String[] strings = new String[]{"1", "22"};
//	1. 在一条语句时，可以简写
Object[] objects = {600, "张飞", "蛮牛式"};
String[] strings = {"1", "22"};
//	2. 作为实参时，将后半部分传入
new Object[]{600, "张飞", "蛮牛式"};
new String[]{"1", "22"};
```

### 84. 配置基于注解的声明式事务管理功能

```java
//  编写一个方法完成用户购买商品业务
//  1. 使用 Transactional 可以进行声明式事务控制
//  2. 即将标识的方法中的，对数据库的操作作为一个事务管理
@Transactional
public void buyGoodsByTx(int userId, int goodsId, int amount){
    System.out.println("用户购买信息 userId= " + userId + "goodsId= " + goodsId + "amount= " + amount);
    Float price = goodsDao.queryPriceById(goodsId);    //  价格
    goodsDao.updateBalance(userId, price * amount);    //  减少用户余额 【先付款，后减少库存量】

    goodsDao.updateAmount(goodsId, amount); //  减少库存量
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- 指定扫描包位置 -->
    <context:component-scan base-package="com.llq.spring.tx"/>
    <!-- 引入外部的 JDBC.properties文件 -->

    <context:property-placeholder location="classpath:JDBC.properties"/>


    <!-- 配置数据源对象==DataSource== -->
    <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource">
        <!--给数据源对象，配置属性值-->
        <property name="user" value="${jdbc.userName}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
    </bean>

    <!-- 配置 JdbcTemplate 对象 -->
    <bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate">
        <!-- 给 JdbcTemplate 对象配置 dataSource 属性-->
        <property name="dataSource" ref="dataSource"/>

    </bean>

    <!-- 配置 NamedParameterJdbcTemplate 对象-->
    <bean class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate" id="namedParameterJdbcTemplate">
        <!-- 通过构造器，设置数据源-->
        <constructor-arg name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 配置事务管理器=== 对象
        1. DataSourceTransactionManager 这个对象是进行事务管理 === debug源码
        2. 一定要配置数据源属性，这样就指定该事务管理器是对哪个数据源进行事务控制
    -->

    <bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="dataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 配置基于注解的声明式事务管理功能 -->
    <tx:annotation-driven transaction-manager="dataSourceTransactionManager"/>

</beans>
```

![jjaq](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202304121133739.png)

### 85. SpringMVC 配置相关

web.xml

- DispatcherServlet
- contextConfigLocation 【指定 Spring 配置文件】

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!-- 配置 前端控制器 / 中央控制器 / 分发控制器
        1. 用户的请求都会经过它的处理
    -->
    <servlet>
        <servlet-name>springDispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 配置属性 contextConfigLocation，指定 springDispatcherServlet 去操作的 Spring 配置文件 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext-mvc.xml</param-value>
        </init-param>
        <!--在 web 项目启动时，就自动地加载 DispatcherServlet -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springDispatcherServlet</servlet-name>
        <!-- 老师说明
            1. 这里我们配置的 url-pattern 是 /，表示用户的请求都经过 springDispatcherServlet
            2. 这样配置也支持 rest 风格的 url 请求
        -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

applicationContext-mvc.xml 配置

视图解析器 InternalResourceViewResolver 【容器中只会有一个视图解析器】

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <!-- Spring 配置文件 -->

    <!-- 配置自动扫描包-->
    <context:component-scan base-package="com.llq.web"/>

    <!-- 配置视图解析器 -->
    <!-- 在整个容器中，只会有一个视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 配置属性 suffix 和 prefix -->
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
</beans>
```











